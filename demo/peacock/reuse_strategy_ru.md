## Цель

В идеале хочется иметь некую платформу aka storefront SDK,
которая обеспечивает переиспользования кода на достаточно высоком уровне,
но в тоже время позволяет иметь сильную кастомизацию конечного контента. Это нелегкая задача сама по себе,
но при должном усилии решаемая.

В будущем на базе SDK можно построить storefront CMS, где собственно сайт можно будет создавать в автономном режиме,
подключая различные блоки на некоторый скелет приложения.

## Путь развития

Исходя из того, что в будущем хочется иметь модульность и переиспользуемость,
необходимо отойти от манеры писать приложение в монолитнем стиле, по возможности. Да, это удобнее и быстрее,
но это противоречит нашим базовым целям.
Для этого нужно выстраивать отдельные куски(модули) приложения, такие как чекаут, форма биллинга, и т.п.
cо строго заданными интерфейсами ( в свою очередь для этого больше подходит TypeScript нежели чем ES6+flow ).э

В идеале получаем приверно такую картину:

Skeleton -> Modules(Components) tree

С точки зрения реакта, модуль на уровне представления это React Component, но имеет строго заданный интерфейс использования.
Модуль включает в себя также:

1. Логику получения и обработки данных от API
2. Логику роутинга для данного модуля
3. Статичные ресурсы (картинкы, фонты, etc)
4. Любую другую meta информацию необходимую для полноценного функционирования в системе

Данный подход позволит избавится от монолитности всей конструкции и получить модульное устройство.

Для поддержки модульности приложение должно иметь

1. Способ подключать доп. роуты из модуля
2. Уметь видеть требования одних модулей относительно других, например один модуль может требовать наличия в системе 
   роутов от некоторых других модулей, или просто один модуль может зависеть от другого.
3. Способ подключать статичные ресурсы из модулей


## Технологии переиспользования

Для начала разберем наш модуль, его цикл жизни.

Он:

1. Получает данные из API и обрабатывает их
2. Рисует получившиеся данные
3. Имеет некоторую логику обработки событий от пользователя и системы
4. Общается с API и системой

В принципе любой из этих кусков может потребовать некоторой кастомизации для конечного продукта.
Но чаще всего требуется только другой внешний вид.
К сожалению в реакте второй и третий и четвертый пункты довольно сильно связаны, но мы можем постараться уменьшить
связность пользуясь имеющимися средствами.

Вообще, наилучшии показатели переиспользования на уровне представления (второй пункт в списке) имеет технология 
XSLT и родственные им (https://github.com/pasaran/yate for example with xml-free syntax).
Это действительно мощный инструмент, который имеет широкие возможности
для преобразования исходного шаблона в нужные форму.

В итоге, здесь, уже на уровне модуля, мы тоже имеем стратегию меньшей связности.

Что мы уже сейчас можем для этого сделать

Во первых, разделять компоненты на умные контэйнеры и тупых рисовальщиков, оба имеют заданный интерфейс.
Вся логика по получению данных из API, обработке событий и взаимодействия системы должна быть в умном компоненте.

На первом этапе даже этого может быть достаточно, учитывая, например, некоторый механизм наследования модулей,
в котором мы можем, например, переопределять методы умного контэйнера, или целиком заменить компонент ответственный
за отрисовку.

## механизм наследования модулей

to be continued
