
import _ from 'lodash';
import { assoc } from 'sprout-data';
import {createAction} from 'redux-act';

export function reducer(state = {}, action) {
  const kind = _.get(action, 'meta.kind');
  if (kind == 'async') {
    const { type, namespace } = action.meta;
    switch (type) {
      case 'started':
        return assoc(state,
          [namespace, 'inProgress'], true,
          [namespace, 'finished'], false
        );
      case 'succeeded':
      case 'failed':
        return assoc(state,
          [namespace, 'inProgress'], false,
          [namespace, 'finished'], true
        );
      default:
        return state;
    }
  }
  return state;
}

function createAsyncAction(namespace, type, payloadReducer) {
  const description = `${namespace.toUpperCase()}_${type.toUpperCase()}`;
  return createAction(description, payloadReducer, () => ({
    kind: 'async',
    namespace,
    type,
  }));
}

export default function createAsyncActions(namespace, asyncCall, payloadReducer) {
  const actions = {
    fetchStarted: createAsyncAction(namespace, 'started', payloadReducer),
    fetchSucceeded: createAsyncAction(namespace, 'succeeded', payloadReducer),
    fetchFailed: createAsyncAction(namespace, 'failed', payloadReducer),
  };

  /* eslint-disable consistent-return */

  const fetch = (...args) => {
    return (dispatch, getState) => {
      const asyncState = _.get(getState(), ['asyncActions', namespace]);
      if (asyncState && (asyncState.inProgress || asyncState.finished)) return;

      dispatch(actions.fetchStarted(...args));
      return asyncCall(...args)
        .then(
          res => dispatch(actions.fetchSucceeded(res))
        ).catch(err => {
          dispatch(actions.fetchFailed(err));
          throw err;
        });
    };
  };

  /* eslint-enable consistent-return */

  return {
    fetch,
    actions,
  };
}
