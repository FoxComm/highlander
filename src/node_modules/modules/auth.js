
/* @flow weak */

import { createAction, createReducer } from 'redux-act';
import fetch from 'isomorphic-fetch';
import { phoenix } from 'lib/api';

// types

export type TUser = {name: String, email: String};

export type LoginPayload = {
  email: string,
  password: string,
  kind: string,
};

export type UserState = {
  err: ?String,
  user: ?TUser,
  isFetching: boolean,
};

export type SignUpPayload = {
  name: string,
  email: string,
  password: string,
};

export const setUser = createAction('USER_SET');
export const setJwt = createAction('AUTH_SET_JWT');
const authStart = createAction('USER_AUTH_START');
const authError = createAction('USER_AUTH_ERROR');

const headers = {'Content-Type': 'application/json;charset=UTF-8'};

export function signUp(payload: SignUpPayload) {
  return () => {
    return phoenix.post('/v1/public/registrations/new', payload).then((data) => {
      return data;
    }).catch((err) => {
      console.error(err);
    });
  };
}

export function authenticate(payload: LoginPayload) {
  return dispatch => {
    dispatch(authStart());
    return fetch('/api/v1/public/login', {
      method: 'POST',
      body: JSON.stringify(payload),
      credentials: 'same-origin',
      headers,
    }).then(response => {
      const jwt = response.headers.get('jwt');
      if (response.status == 200 && jwt) {
        localStorage.setItem('jwt', jwt);
        dispatch(setJwt(jwt));
        return response.json();
      }
      throw new Error('Server error, try again later. Sorry for inconvenience :(');
    }).then((token) => {
      if (token.email && token.name) {
        localStorage.setItem('user', JSON.stringify(token));
        return dispatch(setUser(token));
      }
      throw new Error('Server error, try again later. Sorry for inconvenience :(');
    }).catch(reason => {
      dispatch(authError(reason));
      throw new Error(reason);
    });
  };
}

const initialState = {isFetching: false};

const reducer = createReducer({
  [setUser]: (state, user) => {
    return {
      ...state,
      user,
      isFetching: false,
    };
  },
  [setJwt]: (state, jwt) => {
    return {
      ...state,
      jwt,
    };
  },
  [authStart]: (state) => {
    return {
      ...state,
      err: null,
      isFetching: true,
    };
  },
  [authError]: (state, err) => {
    return {
      ...state,
      err,
      isFetching: false,
    };
  },
}, initialState);

export default reducer;
