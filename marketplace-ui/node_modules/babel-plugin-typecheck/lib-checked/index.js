'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally {try{if(!_n&&_i["return"])_i["return"]();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol?"symbol":typeof obj;};exports.default=function(_ref102){var t=_ref102.types;var template=_ref102.template; /**
   * Binary Operators that can only produce boolean results.
   */var BOOLEAN_BINARY_OPERATORS=['==','===','>=','<=','>','<','instanceof'];if(!(Array.isArray(BOOLEAN_BINARY_OPERATORS)&&BOOLEAN_BINARY_OPERATORS.every(function(item){return typeof item==='string';}))){throw new TypeError('Value of variable "BOOLEAN_BINARY_OPERATORS" violates contract.\n\nExpected:\nstring[]\n\nGot:\n'+_inspect(BOOLEAN_BINARY_OPERATORS));}var checks=createChecks();var staticChecks=createStaticChecks();var checkIsArray=expression('Array.isArray(input)');if(!(typeof checkIsArray==='function')){throw new TypeError('Value of variable "checkIsArray" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkIsArray));}var checkIsMap=expression('input instanceof Map');if(!(typeof checkIsMap==='function')){throw new TypeError('Value of variable "checkIsMap" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkIsMap));}var checkIsSet=expression('input instanceof Set');if(!(typeof checkIsSet==='function')){throw new TypeError('Value of variable "checkIsSet" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkIsSet));}var checkIsClass=expression('typeof input === \'function\' && input.prototype && input.prototype.constructor === input');if(!(typeof checkIsClass==='function')){throw new TypeError('Value of variable "checkIsClass" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkIsClass));}var checkIsGenerator=expression('typeof input === \'function\' && input.generator');if(!(typeof checkIsGenerator==='function')){throw new TypeError('Value of variable "checkIsGenerator" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkIsGenerator));}var checkIsIterable=expression('input && (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');if(!(typeof checkIsIterable==='function')){throw new TypeError('Value of variable "checkIsIterable" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkIsIterable));}var checkIsObject=expression('input != null && typeof input === \'object\'');if(!(typeof checkIsObject==='function')){throw new TypeError('Value of variable "checkIsObject" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkIsObject));}var checkNotNull=expression('input != null');if(!(typeof checkNotNull==='function')){throw new TypeError('Value of variable "checkNotNull" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkNotNull));}var checkEquals=expression('input === expected');if(!(typeof checkEquals==='function')){throw new TypeError('Value of variable "checkEquals" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkEquals));}var declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');if(!(typeof declareTypeChecker==='function')){throw new TypeError('Value of variable "declareTypeChecker" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(declareTypeChecker));}var guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');if(!(typeof guard==='function')){throw new TypeError('Value of variable "guard" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(guard));}var thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');if(!(typeof thrower==='function')){throw new TypeError('Value of variable "thrower" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(thrower));}var guardInline=expression('\n    (id => {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');if(!(typeof guardInline==='function')){throw new TypeError('Value of variable "guardInline" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(guardInline));}var guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');if(!(typeof guardFn==='function')){throw new TypeError('Value of variable "guardFn" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(guardFn));}var readableName=expression('\n    inspect(input)\n  ');if(!(typeof readableName==='function')){throw new TypeError('Value of variable "readableName" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(readableName));}var checkMapKeys=expression('\n    input instanceof Map && Array.from(input.keys()).every(key => keyCheck)\n  ');if(!(typeof checkMapKeys==='function')){throw new TypeError('Value of variable "checkMapKeys" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkMapKeys));}var checkMapValues=expression('\n    input instanceof Map && Array.from(input.values()).every(value => valueCheck)\n  ');if(!(typeof checkMapValues==='function')){throw new TypeError('Value of variable "checkMapValues" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkMapValues));}var checkMapEntries=expression('\n    input instanceof Map && Array.from(input).every(([key, value]) => keyCheck && valueCheck)\n  ');if(!(typeof checkMapEntries==='function')){throw new TypeError('Value of variable "checkMapEntries" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkMapEntries));}var checkSetEntries=expression('\n    input instanceof Set && Array.from(input).every(value => valueCheck)\n  ');if(!(typeof checkSetEntries==='function')){throw new TypeError('Value of variable "checkSetEntries" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkSetEntries));}var checkObjectIndexers=expression('\n    Object.keys(input).every(key => {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');if(!(typeof checkObjectIndexers==='function')){throw new TypeError('Value of variable "checkObjectIndexers" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkObjectIndexers));}var checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key => {\n      const value = input[key];\n      return check;\n    });\n  ');if(!(typeof checkObjectIndexersNoFixed==='function')){throw new TypeError('Value of variable "checkObjectIndexersNoFixed" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(checkObjectIndexersNoFixed));}var propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');if(!(typeof propType==='function')){throw new TypeError('Value of variable "propType" violates contract.\n\nExpected:\n() => Node\n\nGot:\n'+_inspect(propType));}var PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;var PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;function skipEnvironment(comments,opts){if(!opts.only){return false;}var envs=pragmaEnvironments(comments);return !opts.only.some(function(env){return envs[env];});}function pragmaEnvironments(comments){var pragma=/@typecheck:\s*(.+)/;var environments={};comments.forEach(function(comment){var m=comment.value.match(pragma);if(m){m[1].split(',').forEach(function(env){return environments[env.trim()]=true;});}});return environments;}var visitors={Statement:function Statement(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}maybeSkip(path);},TypeAlias:function TypeAlias(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(maybeSkip(path)){return;}path.replaceWith(createTypeAliasChecks(path));},InterfaceDeclaration:function InterfaceDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(maybeSkip(path)){return;}path.replaceWith(createInterfaceChecks(path));},ExportNamedDeclaration:function ExportNamedDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;if(node.declaration&&node.declaration.type==='TypeAlias'){var declaration=path.get('declaration');declaration.replaceWith(createTypeAliasChecks(declaration));node.exportKind='value';}},ImportDeclaration:function ImportDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(maybeSkip(path)){return;}if(path.node.importKind!=='type'){return;}var _path$get$map$reduce=path.get('specifiers').map(function(specifier){var local=specifier.get('local');var tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);var replacement=t.importSpecifier(tmpId,specifier.node.imported);var id=t.identifier(local.node.name);id.isTypeChecker=true;var declarator=t.variableDeclarator(id,tmpId);declarator.isTypeChecker=true;return [declarator,replacement];}).reduce(function(_ref103,_ref104){var _ref106=_slicedToArray(_ref103,2);var declarators=_ref106[0];var specifiers=_ref106[1];var _ref105=_slicedToArray(_ref104,2);var declarator=_ref105[0];var specifier=_ref105[1];declarators.push(declarator);specifiers.push(specifier);return [declarators,specifiers];},[[],[]]);var _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);var declarators=_path$get$map$reduce2[0];var specifiers=_path$get$map$reduce2[1];var declaration=t.variableDeclaration('var',declarators);declaration.isTypeChecker=true;path.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);},ArrowFunctionExpression:function ArrowFunctionExpression(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));} // Look for destructuring args with annotations.
var params=path.get('params');if(!(Array.isArray(params)&&params.every(function(item){return NodePath(item);}))){throw new TypeError('Value of variable "params" violates contract.\n\nExpected:\nNodePath[]\n\nGot:\n'+_inspect(params));}if(!(params&&(typeof params[Symbol.iterator]==='function'||Array.isArray(params)))){throw new TypeError('Expected params to be iterable, got '+_inspect(params));}var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var param=_step.value;if(param.isObjectPattern()&&param.node.typeAnnotation){var _path$get5=path.get('body');var _scope=_path$get5.scope;var _id117=_scope.generateUidIdentifier('arg'+param.key);var pattern=param.node;param.replaceWith(_id117);if(path.node.expression){var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id117)]),t.returnStatement(path.get('body').node)]);path.node.body=block;path.node.expression=false;}else {path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id117)]));}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally {try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally {if(_didIteratorError){throw _iteratorError;}}}},Function:{enter:function enter(path,context){var _node$body$body;if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var paramChecks=collectParamChecks(path,context);if(node.type==="ArrowFunctionExpression"&&node.expression){node.expression=false;node.body=t.blockStatement([t.returnStatement(node.body)]);}if(node.returnType){createFunctionReturnGuard(path,context);createFunctionYieldGuards(path,context);}(_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));node.savedTypeAnnotation=node.returnType;node.returnCount=0;node.yieldCount=0;},exit:function exit(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;var scope=path.scope;var isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;if(!node.returnCount&&isVoid===false){var annotation=node.savedTypeAnnotation;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(node.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}throw path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'"'+node.id.name+'" ':'')+'did not return a value.',annotation));}if(node.nextGuardCount){path.get('body').get('body')[0].insertBefore(node.nextGuard);}if(node.yieldGuardCount){path.get('body').get('body')[0].insertBefore(node.yieldGuard);}if(node.returnGuardCount){path.get('body').get('body')[0].insertBefore(node.returnGuard);}}},YieldExpression:function YieldExpression(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var fn=path.getFunctionParent();if(!fn){return;}fn.node.yieldCount++;if(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var annotation=fn.node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];var ok=staticCheckAnnotation(path.get("argument"),yieldType);if(ok===true&&!nextType){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}fn.node.yieldGuardCount++;if(fn.node.yieldGuard){var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));_yielder.hasBeenTypeChecked=true;if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}else {path.replaceWith(_yielder);}}else if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}},ReturnStatement:function ReturnStatement(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var fn=path.getFunctionParent();if(!fn){return;}fn.node.returnCount++;if(maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var _fn$node=fn.node;var returnType=_fn$node.returnType;var returnGuardName=_fn$node.returnGuardName;if(!returnType||!returnGuardName){return;}if(!node.argument){if(maybeNullableAnnotation(returnType)===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'did not return a value.',returnType));}return;}var annotation=returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var ok=staticCheckAnnotation(path.get("argument"),annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}fn.node.returnGuardCount++;var returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));returner.hasBeenTypeChecked=true;path.replaceWith(returner);},VariableDeclaration:function VariableDeclaration(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var collected=[];var declarations=path.get("declarations");for(var i=0;i<node.declarations.length;i++){var declaration=node.declarations[i];var _id118=declaration.id;var init=declaration.init;if(!_id118.typeAnnotation||_id118.hasBeenTypeChecked){continue;}_id118.savedTypeAnnotation=_id118.typeAnnotation;_id118.hasBeenTypeChecked=true;var ok=staticCheckAnnotation(declarations[i],_id118.typeAnnotation);if(ok===true){continue;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+_id118.name+'".',_id118.typeAnnotation,getAnnotation(declarations[i])));}var check=checkAnnotation(_id118,_id118.typeAnnotation,scope);if(check){collected.push(guard({check:check,message:varTypeErrorMessage(_id118,context)}));}}if(collected.length>0){var _check=collected.reduce(function(check,branch){branch.alternate=check;return branch;});if(path.parent.type==='Program'||path.parent.type==='BlockStatement'){path.insertAfter(_check);}else if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){var body=path.parentPath.get('body');if(body.type!=='BlockStatement'){var block=t.blockStatement([body.node]);body.replaceWith(block);body=path.parentPath.get('body');}var children=body.get('body');if(children.length===0){body.replaceWith(_check);}else {children[0].insertBefore(_check);}}else if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){path.parentPath.insertAfter(_check);}else {path.replaceWith(t.blockStatement([node,_check]));}}},AssignmentExpression:function AssignmentExpression(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var left=path.get('left');var annotation=void 0;if(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){return;}else if(left.isMemberExpression()){annotation=getAnnotation(left);}else if(t.isIdentifier(node.left)){var binding=scope.getBinding(node.left.name);if(!binding){return;}else if(binding.path.type!=='VariableDeclarator'){return;}annotation=left.getTypeAnnotation();if(annotation.type==='AnyTypeAnnotation'){var item=binding.path.get('id');annotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}}else {return;}node.hasBeenTypeChecked=true;node.left.hasBeenTypeChecked=true;var id=node.left;var right=path.get('right');if(annotation.type==='AnyTypeAnnotation'){return;}var ok=staticCheckAnnotation(right,annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+humanReadableType(id)+'".',annotation,getAnnotation(right)));}var check=checkAnnotation(id,annotation,scope);if(!id.typeAnnotation){id.typeAnnotation=annotation;}id.hasBeenTypeChecked=true;if(check){var parent=path.getStatementParent();parent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}},TypeCastExpression:function TypeCastExpression(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;var target=void 0;switch(node.expression.type){case 'Identifier':target=node.expression;break;case 'AssignmentExpression':target=node.expression.left;break;default: // unsupported.
return;}var id=path.scope.getBindingIdentifier(target.name);if(!id){return;}id.savedTypeAnnotation=path.getTypeAnnotation();},ForOfStatement:function ForOfStatement(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}if(maybeSkip(path)){return;}var left=path.get('left');if(!NodePath(left)){throw new TypeError('Value of variable "left" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(left));}var right=path.get('right');if(!NodePath(right)){throw new TypeError('Value of variable "right" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(right));}var rightAnnotation=getAnnotation(right);if(!TypeAnnotation(rightAnnotation)){throw new TypeError('Value of variable "rightAnnotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(rightAnnotation));}var leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);if(!TypeAnnotation(leftAnnotation)){throw new TypeError('Value of variable "leftAnnotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(leftAnnotation));}if(rightAnnotation.type!=='VoidTypeAnnotation'&&rightAnnotation.type!=='NullLiteralTypeAnnotation'){var ok=maybeIterableAnnotation(rightAnnotation);if(!(ok==null||typeof ok==='boolean')){throw new TypeError('Value of variable "ok" violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(ok));}if(ok===false){throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}}var id=void 0;if(!(id==null||Identifier(id))){throw new TypeError('Value of variable "id" violates contract.\n\nExpected:\n?Identifier\n\nGot:\n'+_inspect(id));}if(right.isIdentifier()){id=right.node;if(!(id==null||Identifier(id))){throw new TypeError('Value of variable "id" violates contract.\n\nExpected:\n?Identifier\n\nGot:\n'+_inspect(id));}}else {id=path.scope.generateUidIdentifierBasedOnNode(right.node);if(!(id==null||Identifier(id))){throw new TypeError('Value of variable "id" violates contract.\n\nExpected:\n?Identifier\n\nGot:\n'+_inspect(id));}path.scope.push({id:id});var replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));if(!Node(replacement)){throw new TypeError('Value of variable "replacement" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(replacement));}path.insertBefore(replacement);right.replaceWith(id);}path.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));if(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){return;}var annotation=rightAnnotation.typeParameters.params[0];if(!TypeAnnotation(annotation)){throw new TypeError('Value of variable "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(compareAnnotations(annotation,leftAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}},ClassDeclaration:function ClassDeclaration(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));} // Convert React props to propTypes
if(!path.node.superClass){return;}var props=void 0;if(!(props==null||NodePath(props))){throw new TypeError('Value of variable "props" violates contract.\n\nExpected:\n?NodePath\n\nGot:\n'+_inspect(props));}var hasRenderMethod=false;_path$get=path.get('body.body');if(!(_path$get&&(typeof _path$get[Symbol.iterator]==='function'||Array.isArray(_path$get)))){throw new TypeError('Expected _path$get to be iterable, got '+_inspect(_path$get));}var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=_path$get[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var _path$get;var memberPath=_step2.value;var classMember=memberPath.node;if(t.isClassProperty(classMember)){if(classMember.key.name==='propTypes'&&classMember.static){return;}else if(classMember.key.name==='props'&&!classMember.static){props=memberPath;if(!(props==null||NodePath(props))){throw new TypeError('Value of variable "props" violates contract.\n\nExpected:\n?NodePath\n\nGot:\n'+_inspect(props));}}}if(t.isClassMethod(classMember)&&classMember.key.name==='render'){hasRenderMethod=true;}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally {try{if(!_iteratorNormalCompletion2&&_iterator2.return){_iterator2.return();}}finally {if(_didIteratorError2){throw _iteratorError2;}}}var type=void 0;if(!(type==null||Node(type))){throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}if(path.node.superTypeParameters){if(path.node.superTypeParameters.params.length!==3){return;}type=path.node.superTypeParameters.params[1];if(!(type==null||Node(type))){throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}}if(props){type=props.node.typeAnnotation.typeAnnotation;if(!(type==null||Node(type))){throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}}if(!type||!hasRenderMethod){return;}if(t.isGenericTypeAnnotation(type)){var binding=path.scope.getBinding(type.id.name);type=getAnnotation(binding.path);if(!(type==null||Node(type))){throw new TypeError('Value of variable "type" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(type));}}if(!t.isObjectTypeAnnotation(type)){return;} // Now we have a class that has a superclass, an instance method called 'render'
// and some property type annotations. We can be reasonably sure it's a React component.
var propTypes=t.objectExpression(type.properties.map(function(prop){return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}));if(path.node.decorators){var property=t.classProperty(t.identifier('propTypes'),propTypes);property.static=true;props.insertAfter(property);}else {var root=path.parentPath.isExportDeclaration()?path.parentPath:path;if(!NodePath(root)){throw new TypeError('Value of variable "root" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(root));}root.insertAfter(t.expressionStatement(t.assignmentExpression("=",t.memberExpression(path.node.id,t.identifier("propTypes")),propTypes)));}}}; /**
   * Collect all the type declarations in the given path and add references to them for retreival later.
   */function collectTypes(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}path.traverse({InterfaceDeclaration:function InterfaceDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}path.scope.setData('typechecker:'+path.node.id.name,path);},TypeAlias:function TypeAlias(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}path.scope.setData('typechecker:'+path.node.id.name,path);},ImportDeclaration:function ImportDeclaration(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(path.node.importKind!=='type'){return;}path.get('specifiers').forEach(function(specifier){var local=specifier.get('local');if(local.isIdentifier()){path.scope.setData('typechecker:'+local.node.name,specifier);}else {path.scope.setData('typechecker:'+local.node.id.name,specifier);}});},"Function|Class":function FunctionClass(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;if(node.typeParameters&&node.typeParameters.params){path.get('typeParameters').get('params').forEach(function(typeParam){path.get('body').scope.setData('typeparam:'+typeParam.node.name,typeParam);});}}});}return {visitor:{Program:function Program(path,_ref107){var opts=_ref107.opts;if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(opts&&opts.disable&&opts.disable[process.env.NODE_ENV]){return;}var checkFile=false;_path$get2=path.get('body');if(!(_path$get2&&(typeof _path$get2[Symbol.iterator]==='function'||Array.isArray(_path$get2)))){throw new TypeError('Expected _path$get2 to be iterable, got '+_inspect(_path$get2));}var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=_path$get2[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var _path$get2;var _child=_step3.value;if(mustCheckFile(_child,opts)){checkFile=true;break;}}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally {try{if(!_iteratorNormalCompletion3&&_iterator3.return){_iterator3.return();}}finally {if(_didIteratorError3){throw _iteratorError3;}}}if(!checkFile){_path$get3=path.get('body');if(!(_path$get3&&(typeof _path$get3[Symbol.iterator]==='function'||Array.isArray(_path$get3)))){throw new TypeError('Expected _path$get3 to be iterable, got '+_inspect(_path$get3));}var _iteratorNormalCompletion4=true;var _didIteratorError4=false;var _iteratorError4=undefined;try{for(var _iterator4=_path$get3[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){var _path$get3;var child=_step4.value;if(maybeSkipFile(child,opts)){return;}}}catch(err){_didIteratorError4=true;_iteratorError4=err;}finally {try{if(!_iteratorNormalCompletion4&&_iterator4.return){_iterator4.return();}}finally {if(_didIteratorError4){throw _iteratorError4;}}}}collectTypes(path);var inspect=path.scope.generateUidIdentifier('inspect');var requiresHelpers={inspect:false};var context={get inspect(){requiresHelpers.inspect=true;return inspect;}};path.traverse(visitors,context);if(requiresHelpers.inspect){var body=path.get('body');body[body.length-1].insertAfter(template('\n            function id (input, depth) {\n              const maxDepth = 4;\n              const maxKeys = 15;\n              if (depth === undefined) {\n                depth = 0;\n              }\n              depth += 1;\n              if (input === null) {\n                return \'null\';\n              }\n              else if (input === undefined) {\n                return \'void\';\n              }\n              else if (typeof input === \'string\' || typeof input === \'number\' || typeof input === \'boolean\') {\n                return typeof input;\n              }\n              else if (Array.isArray(input)) {\n                if (input.length > 0) {\n                  if (depth > maxDepth) return \'[...]\';\n                  const first = id(input[0], depth);\n                  if (input.every(item => id(item, depth) === first)) {\n                    return first.trim() + \'[]\';\n                  }\n                  else {\n                    return \'[\' + input.slice(0, maxKeys).map(item => id(item, depth)).join(\', \') + (input.length >= maxKeys ? \', ...\' : \'\') + \']\';\n                  }\n                }\n                else {\n                  return \'Array\';\n                }\n              }\n              else {\n                const keys = Object.keys(input);\n                if (!keys.length) {\n                  if (input.constructor && input.constructor.name && input.constructor.name !== \'Object\') {\n                    return input.constructor.name;\n                  }\n                  else {\n                    return \'Object\';\n                  }\n                }\n                if (depth > maxDepth) return \'{...}\';\n                const indent = \'  \'.repeat(depth - 1);\n                let entries = keys.slice(0, maxKeys).map(key => {\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \': \' + id(input[key], depth) + \';\';\n                }).join(\'\\n  \' + indent);\n                if (keys.length >= maxKeys) {\n                  entries += \'\\n  \' + indent + \'...\';\n                }\n                if (input.constructor && input.constructor.name && input.constructor.name !== \'Object\') {\n                  return input.constructor.name + \' {\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n                else {\n                  return \'{\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n              }\n            }\n          ')({id:inspect}));}}}}; /**
   * Create a function which can verify the return type for a function.
   */function createFunctionReturnGuard(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var name=scope.generateUidIdentifierBasedOnNode(node);var id=scope.generateUidIdentifier('id');var check=checkAnnotation(id,annotation,scope);if(check){node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});node.returnGuard.hasBeenTypeChecked=true;node.returnGuardName=name;node.returnGuardCount=0;}}function createFunctionYieldGuards(path,context){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!isGeneratorAnnotation(annotation)){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];if(yieldType){var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');var _id119=scope.generateUidIdentifier('id');var check=checkAnnotation(_id119,yieldType,scope);if(check){node.yieldGuard=guardFn({id:_id119,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id119,context)});node.yieldGuardName=_name;node.yieldGuardCount=0;}}if(nextType){var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');var _id120=scope.generateUidIdentifier('id');var _check2=checkAnnotation(_id120,nextType,scope);if(_check2){node.nextGuard=guardFn({id:_id120,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id120,context)});node.nextGuardName=_name2;node.nextGuardCount=0;}}}function isThisMemberExpression(path){function _ref4(_id17){if(!(typeof _id17==='boolean')){throw new TypeError('Function "isThisMemberExpression" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id17));}return _id17;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;if(node.type==='ThisExpression'){return true;}else if(node.type==='MemberExpression'){return _ref4(isThisMemberExpression(path.get('object')));}else {return false;}}function isGeneratorAnnotation(annotation){if(!(annotation==null||TypeAnnotation(annotation))){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(!annotation){return false;}if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Generator';}function buildErrorMessage(message,expected,got){if(!(typeof message==='string')){throw new TypeError('Value of argument "message" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(message));}if(!TypeAnnotation(expected)){throw new TypeError('Value of argument "expected" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(expected));}if(!(got==null||Node(got))){throw new TypeError('Value of argument "got" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(got));}if(got){return message+'\n\nExpected:\n'+humanReadableType(expected)+'\n\nGot:\n'+humanReadableType(got);}else {return message+'\n\nExpected:\n'+humanReadableType(expected);}}function createChecks(){return {number:expression('typeof input === \'number\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \'boolean\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \'function\''),string:expression('typeof input === \'string\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \'symbol\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:function mixed(){return null;},any:function any(){return null;},union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \'number\' && !isNaN(input) && input >= -128 && input <= 127 && input === Math.floor(input)'),uint8:expression('typeof input === \'number\' && !isNaN(input) && input >= 0 && input <= 255 && input === Math.floor(input)'),int16:expression('typeof input === \'number\' && !isNaN(input) && input >= -32768 && input <= 32767 && input === Math.floor(input)'),uint16:expression('typeof input === \'number\' && !isNaN(input) && input >= 0 && input <= 65535 && input === Math.floor(input)'),int32:expression('typeof input === \'number\' && !isNaN(input) && input >= -2147483648 && input <= 2147483647 && input === Math.floor(input)'),uint32:expression('typeof input === \'number\' && !isNaN(input) && input >= 0 && input <= 4294967295 && input === Math.floor(input)'),float32:expression('typeof input === \'number\' && !isNaN(input) && input >= -3.40282347e+38 && input <= 3.40282347e+38'),float64:expression('typeof input === \'number\' && !isNaN(input)'),double:expression('typeof input === \'number\' && !isNaN(input)')};}function createStaticChecks(){return {symbol:function symbol(path){function _symbol(_id21){if(!(_id21==null||typeof _id21==='boolean')){throw new TypeError('Function return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id21));}return _id21;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}return _symbol(maybeSymbolAnnotation(getAnnotation(path)));},instanceof:function _instanceof(_ref108){var path=_ref108.path;var annotation=_ref108.annotation;function _instanceof(_id22){if(!(_id22==null||typeof _id22==='boolean')){throw new TypeError('Function return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id22));}return _id22;}var type=createTypeExpression(annotation.id);var node=path.node;var scope=path.scope;if(type.name==='Object'&&node.type==='ObjectExpression'&&!scope.getBinding('Object')){return true;}else if(type.name==='Map'&&!scope.getBinding('Map')){return _instanceof(null);}else if(type.name==='Set'&&!scope.getBinding('Set')){return _instanceof(null);}else if(type.name==='Class'&&!scope.hasBinding('Class')){return _instanceof(null);}else if(type.name==='int8'&&!scope.hasBinding('int8')){return _instanceof(null);}else if(type.name==='uint8'&&!scope.hasBinding('uint8')){return _instanceof(null);}else if(type.name==='int16'&&!scope.hasBinding('int16')){return _instanceof(null);}else if(type.name==='uint16'&&!scope.hasBinding('uint16')){return _instanceof(null);}else if(type.name==='int32'&&!scope.hasBinding('int32')){return _instanceof(null);}else if(type.name==='uint32'&&!scope.hasBinding('uint32')){return _instanceof(null);}else if(type.name==='float32'&&!scope.hasBinding('float32')){return _instanceof(null);}else if(type.name==='float64'&&!scope.hasBinding('float64')){return _instanceof(null);}else if(type.name==='double'&&!scope.hasBinding('double')){return _instanceof(null);}return _instanceof(maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]));},type:function(_type2){function type(_x){return _type2.apply(this,arguments);}type.toString=function(){return _type2.toString();};return type;}(function(_ref109){var path=_ref109.path;var type=_ref109.type;function _type(_id23){if(!(_id23==null||typeof _id23==='boolean')){throw new TypeError('Function return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id23));}return _id23;}return _type(null);})};}function compareAnnotations(a,b){function _ref8(_id24){if(!(_id24==null||typeof _id24==='boolean')){throw new TypeError('Function "compareAnnotations" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id24));}return _id24;}if(!TypeAnnotation(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}if(a.type==='TypeAnnotation'){a=a.typeAnnotation;}if(b.type==='TypeAnnotation'){b=b.typeAnnotation;}switch(a.type){case 'StringTypeAnnotation':return _ref8(maybeStringAnnotation(b));case 'StringLiteral':case 'StringLiteralTypeAnnotation':return _ref8(compareStringLiteralAnnotations(a,b));case 'NumberTypeAnnotation':return _ref8(maybeNumberAnnotation(b));case 'NumericLiteral':case 'NumericLiteralTypeAnnotation':return _ref8(compareNumericLiteralAnnotations(a,b));case 'BooleanTypeAnnotation':return _ref8(maybeBooleanAnnotation(b));case 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':return _ref8(compareBooleanLiteralAnnotations(a,b));case 'FunctionTypeAnnotation':return _ref8(maybeFunctionAnnotation(b));case 'AnyTypeAnnotation':return _ref8(null);case 'MixedTypeAnnotation':return _ref8(null);case 'ObjectTypeAnnotation':return _ref8(compareObjectAnnotation(a,b));case 'ArrayTypeAnnotation':return _ref8(compareArrayAnnotation(a,b));case 'GenericTypeAnnotation':return _ref8(compareGenericAnnotation(a,b));case 'TupleTypeAnnotation':return _ref8(compareTupleAnnotation(a,b));case 'UnionTypeAnnotation':return _ref8(compareUnionAnnotation(a,b));case 'IntersectionTypeAnnotation':return _ref8(compareIntersectionAnnotation(a,b));case 'NullableTypeAnnotation':return _ref8(compareNullableAnnotation(a,b));default:return _ref8(null);}}function compareStringLiteralAnnotations(a,b){if(!StringLiteralTypeAnnotation(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nStringLiteralTypeAnnotation\n\nGot:\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){return a.value===b.value;}else {return maybeStringAnnotation(b)===false?false:null;}}function compareBooleanLiteralAnnotations(a,b){if(!BooleanLiteralTypeAnnotation(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nBooleanLiteralTypeAnnotation\n\nGot:\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){return a.value===b.value;}else {return maybeBooleanAnnotation(b)===false?false:null;}}function compareNumericLiteralAnnotations(a,b){if(!NumericLiteralTypeAnnotation(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNumericLiteralTypeAnnotation\n\nGot:\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){return a.value===b.value;}else {return maybeNumberAnnotation(b)===false?false:null;}}function unionComparer(a,b,comparator){function _ref12(_id28){if(!(_id28==null||typeof _id28==='boolean')){throw new TypeError('Function "unionComparer" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id28));}return _id28;}if(!TypeAnnotation(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}if(!(typeof comparator==='function')){throw new TypeError('Value of argument "comparator" violates contract.\n\nExpected:\n(TypeAnnotation, TypeAnnotation) => ?bool\n\nGot:\n'+_inspect(comparator));}if(!a.types||a.types.length===0){return _ref12(null);}var falseCount=0;var trueCount=0;if(!a.types){return _ref12(null);}_a$types=a.types;if(!(_a$types&&(typeof _a$types[Symbol.iterator]==='function'||Array.isArray(_a$types)))){throw new TypeError('Expected _a$types to be iterable, got '+_inspect(_a$types));}var _iteratorNormalCompletion5=true;var _didIteratorError5=false;var _iteratorError5=undefined;try{for(var _iterator5=_a$types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){var _a$types;var _type3=_step5.value;var result=comparator(_type3,b);if(result===true){if(b.type!=='UnionTypeAnnotation'){return true;}trueCount++;}else if(result===false){if(b.type==='UnionTypeAnnotation'){return false;}falseCount++;}}}catch(err){_didIteratorError5=true;_iteratorError5=err;}finally {try{if(!_iteratorNormalCompletion5&&_iterator5.return){_iterator5.return();}}finally {if(_didIteratorError5){throw _iteratorError5;}}}if(falseCount===a.types.length){return false;}else if(trueCount===a.types.length){return true;}else {return _ref12(null);}}function intersectionComparer(a,b,comparator){function _ref13(_id29){if(!(_id29==null||typeof _id29==='boolean')){throw new TypeError('Function "intersectionComparer" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id29));}return _id29;}if(!TypeAnnotation(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(a));}if(!TypeAnnotation(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(b));}if(!(typeof comparator==='function')){throw new TypeError('Value of argument "comparator" violates contract.\n\nExpected:\n(TypeAnnotation, TypeAnnotation) => ?bool\n\nGot:\n'+_inspect(comparator));}var falseCount=0;var trueCount=0;if(!a.types){return _ref13(null);}_a$types2=a.types;if(!(_a$types2&&(typeof _a$types2[Symbol.iterator]==='function'||Array.isArray(_a$types2)))){throw new TypeError('Expected _a$types2 to be iterable, got '+_inspect(_a$types2));}var _iteratorNormalCompletion6=true;var _didIteratorError6=false;var _iteratorError6=undefined;try{for(var _iterator6=_a$types2[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){var _a$types2;var _type4=_step6.value;var result=comparator(_type4,b);if(result===true){trueCount++;}else if(result===false){return false;}}}catch(err){_didIteratorError6=true;_iteratorError6=err;}finally {try{if(!_iteratorNormalCompletion6&&_iterator6.return){_iterator6.return();}}finally {if(_didIteratorError6){throw _iteratorError6;}}}if(trueCount===a.types.length){return true;}else {return _ref13(null);}}function compareObjectAnnotation(a,b){function _ref14(_id30){if(!(_id30==null||typeof _id30==='boolean')){throw new TypeError('Function "compareObjectAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id30));}return _id30;}if(!Node(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}switch(b.type){case 'ObjectTypeAnnotation':break;case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref14(compareObjectAnnotation(a,b.typeAnnotation));case 'UnionTypeAnnotation':return _ref14(unionComparer(a,b,compareObjectAnnotation));case 'IntersectionTypeAnnotation':return _ref14(intersectionComparer(a,b,compareObjectAnnotation));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return _ref14(null);} // We're comparing two object annotations.
var allTrue=true;_a$properties=a.properties;if(!(_a$properties&&(typeof _a$properties[Symbol.iterator]==='function'||Array.isArray(_a$properties)))){throw new TypeError('Expected _a$properties to be iterable, got '+_inspect(_a$properties));}var _iteratorNormalCompletion7=true;var _didIteratorError7=false;var _iteratorError7=undefined;try{for(var _iterator7=_a$properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){var _a$properties;var aprop=_step7.value;var found=false;_b$properties=b.properties;if(!(_b$properties&&(typeof _b$properties[Symbol.iterator]==='function'||Array.isArray(_b$properties)))){throw new TypeError('Expected _b$properties to be iterable, got '+_inspect(_b$properties));}var _iteratorNormalCompletion8=true;var _didIteratorError8=false;var _iteratorError8=undefined;try{for(var _iterator8=_b$properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){var _b$properties;var bprop=_step8.value;if(bprop.key.name===aprop.key.name){var result=compareAnnotations(aprop.value,bprop.value);if(result===false&&!(aprop.optional&&(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){return false;}else {found=result;}break;}}}catch(err){_didIteratorError8=true;_iteratorError8=err;}finally {try{if(!_iteratorNormalCompletion8&&_iterator8.return){_iterator8.return();}}finally {if(_didIteratorError8){throw _iteratorError8;}}}if(found===false&&!aprop.optional){return false;}allTrue=allTrue&&found===true;}}catch(err){_didIteratorError7=true;_iteratorError7=err;}finally {try{if(!_iteratorNormalCompletion7&&_iterator7.return){_iterator7.return();}}finally {if(_didIteratorError7){throw _iteratorError7;}}}return allTrue?true:null;}function compareArrayAnnotation(a,b){function _ref15(_id31){if(!(_id31==null||typeof _id31==='boolean')){throw new TypeError('Function "compareArrayAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id31));}return _id31;}if(!Node(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref15(compareArrayAnnotation(a,b.typeAnnotation));case 'UnionTypeAnnotation':return _ref15(unionComparer(a,b,compareArrayAnnotation));case 'IntersectionTypeAnnotation':return _ref15(intersectionComparer(a,b,compareArrayAnnotation));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return _ref15(null);}}function compareGenericAnnotation(a,b){function _ref16(_id32){if(!(_id32==null||typeof _id32==='boolean')){throw new TypeError('Function "compareGenericAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id32));}return _id32;}if(!Node(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref16(compareGenericAnnotation(a,b.typeAnnotation));case 'GenericTypeAnnotation':if(b.id.name===a.id.name){return true;}else {return _ref16(null);}case 'UnionTypeAnnotation':return _ref16(unionComparer(a,b,compareGenericAnnotation));case 'IntersectionTypeAnnotation':return _ref16(intersectionComparer(a,b,compareGenericAnnotation));default:return _ref16(null);}}function compareTupleAnnotation(a,b){function _ref17(_id33){if(!(_id33==null||typeof _id33==='boolean')){throw new TypeError('Function "compareTupleAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id33));}return _id33;}if(!Node(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}if(b.type==='TupleTypeAnnotation'){if(b.types.length===0){return _ref17(null);}else if(b.types.length<a.types.length){return false;}return _ref17(a.types.every(function(type,index){return compareAnnotations(type,b.types[index]);}));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref17(compareTupleAnnotation(a,b.typeAnnotation));case 'UnionTypeAnnotation':return _ref17(unionComparer(a,b,compareTupleAnnotation));case 'IntersectionTypeAnnotation':return _ref17(intersectionComparer(a,b,compareTupleAnnotation));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return _ref17(null);}}function compareUnionAnnotation(a,b){function _ref18(_id34){if(!(_id34==null||typeof _id34==='boolean')){throw new TypeError('Function "compareUnionAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id34));}return _id34;}if(!Node(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}switch(b.type){case 'NullableTypeAnnotation':return _ref18(compareUnionAnnotation(a,b.typeAnnotation));case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':return _ref18(null);default:return _ref18(unionComparer(a,b,compareAnnotations));}}function compareNullableAnnotation(a,b){function _ref19(_id35){if(!(_id35==null||typeof _id35==='boolean')){throw new TypeError('Function "compareNullableAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id35));}return _id35;}if(!Node(a)){throw new TypeError('Value of argument "a" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(a));}if(!Node(b)){throw new TypeError('Value of argument "b" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(b));}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref19(compareNullableAnnotation(a,b.typeAnnotation));case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return _ref19(null);}if(compareAnnotations(a.typeAnnotation,b)===true){return true;}else {return _ref19(null);}}function arrayExpressionToTupleAnnotation(path){function _ref20(_id36){if(!TypeAnnotation(_id36)){throw new TypeError('Function "arrayExpressionToTupleAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id36));}return _id36;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var elements=path.get('elements');return _ref20(t.tupleTypeAnnotation(elements.map(function(element){return getAnnotation(element);})));}function checkNullable(_ref110){var input=_ref110.input;var type=_ref110.type;var scope=_ref110.scope;function _ref21(_id37){if(!(_id37==null||Node(_id37))){throw new TypeError('Function "checkNullable" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id37));}return _id37;}var check=checkAnnotation(input,type,scope);if(!check){return;}return _ref21(t.logicalExpression("||",checks.void({input:input}),check));}function checkTypeof(_ref111){var input=_ref111.input;var annotation=_ref111.annotation;var scope=_ref111.scope;function _ref22(_id38){if(!(_id38==null||Node(_id38))){throw new TypeError('Function "checkTypeof" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id38));}return _id38;}switch(annotation.type){case 'GenericTypeAnnotation':var id=annotation.id;var path=Object.assign({},input,{type:id.type,node:id,scope:scope});return _ref22(checkAnnotation(input,getAnnotation(path),scope));default:return _ref22(checkAnnotation(input,annotation,scope));}}function checkStringLiteral(_ref112){var input=_ref112.input;var annotation=_ref112.annotation;function _ref23(_id39){if(!(_id39==null||Node(_id39))){throw new TypeError('Function "checkStringLiteral" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id39));}return _id39;}return _ref23(checkEquals({input:input,expected:t.stringLiteral(annotation.value)}));}function checkNumericLiteral(_ref113){var input=_ref113.input;var annotation=_ref113.annotation;function _ref24(_id40){if(!(_id40==null||Node(_id40))){throw new TypeError('Function "checkNumericLiteral" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id40));}return _id40;}return _ref24(checkEquals({input:input,expected:t.numericLiteral(annotation.value)}));}function checkBooleanLiteral(_ref114){var input=_ref114.input;var annotation=_ref114.annotation;function _ref25(_id41){if(!(_id41==null||Node(_id41))){throw new TypeError('Function "checkBooleanLiteral" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id41));}return _id41;}return _ref25(checkEquals({input:input,expected:t.booleanLiteral(annotation.value)}));}function checkUnion(_ref115){var input=_ref115.input;var types=_ref115.types;var scope=_ref115.scope;function _ref26(_id42){if(!(_id42==null||Node(_id42))){throw new TypeError('Function "checkUnion" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id42));}return _id42;}var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return _ref26(checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression("||",last,check);},null));}function checkIntersection(_ref116){var input=_ref116.input;var types=_ref116.types;var scope=_ref116.scope;function _ref27(_id43){if(!(_id43==null||Node(_id43))){throw new TypeError('Function "checkIntersection" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id43));}return _id43;}var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return _ref27(checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression("&&",last,check);},null));}function checkMap(_ref117){var input=_ref117.input;var types=_ref117.types;var scope=_ref117.scope;function _ref28(_id44){if(!Node(_id44)){throw new TypeError('Function "checkMap" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id44));}return _id44;}var _types=_slicedToArray(types,2);var keyType=_types[0];var valueType=_types[1];var key=t.identifier('key');var value=t.identifier('value');var keyCheck=keyType?checkAnnotation(key,keyType,scope):null;var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!keyCheck){if(!valueCheck){return _ref28(checkIsMap({input:input}));}else {return _ref28(checkMapValues({input:input,value:value,valueCheck:valueCheck}));}}else {if(!valueCheck){return _ref28(checkMapKeys({input:input,key:key,keyCheck:keyCheck}));}else {return _ref28(checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck}));}}}function checkSet(_ref118){var input=_ref118.input;var types=_ref118.types;var scope=_ref118.scope;function _ref29(_id45){if(!Node(_id45)){throw new TypeError('Function "checkSet" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id45));}return _id45;}var _types2=_slicedToArray(types,1);var valueType=_types2[0];var value=t.identifier('value');var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!valueCheck){return _ref29(checkIsSet({input:input}));}else {return _ref29(checkSetEntries({input:input,value:value,valueCheck:valueCheck}));}}function checkGenerator(_ref119){var input=_ref119.input;var types=_ref119.types;var scope=_ref119.scope;function _ref30(_id46){if(!Node(_id46)){throw new TypeError('Function "checkGenerator" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id46));}return _id46;}return _ref30(checkIsGenerator({input:input}));}function checkIterable(_ref120){var input=_ref120.input;var types=_ref120.types;var scope=_ref120.scope;function _ref31(_id47){if(!Node(_id47)){throw new TypeError('Function "checkIterable" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id47));}return _id47;}return _ref31(checkIsIterable({input:input}));}function checkClass(_ref121){var input=_ref121.input;var types=_ref121.types;var scope=_ref121.scope;function _ref32(_id48){if(!Node(_id48)){throw new TypeError('Function "checkClass" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id48));}return _id48;}return _ref32(checkIsClass({input:input}));}function checkArray(_ref122){var input=_ref122.input;var types=_ref122.types;var scope=_ref122.scope;function _ref33(_id49){if(!Node(_id49)){throw new TypeError('Function "checkArray" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id49));}return _id49;}if(!types||types.length===0){return _ref33(checkIsArray({input:input}));}else if(types.length===1){var item=t.identifier('item');var _type5=types[0];var check=checkAnnotation(item,_type5,scope);if(!check){return _ref33(checkIsArray({input:input}));}return _ref33(t.logicalExpression('&&',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))])));}else { // This is a tuple
var _checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return _ref33(_checks.reduce(function(last,check,index){return t.logicalExpression("&&",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength)));}}function checkTuple(_ref123){var input=_ref123.input;var types=_ref123.types;var scope=_ref123.scope;function _ref34(_id50){if(!Node(_id50)){throw new TypeError('Function "checkTuple" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id50));}return _id50;}if(types.length===0){return _ref34(checkIsArray({input:input}));} // This is a tuple
var checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return _ref34(checks.reduce(function(last,check,index){return t.logicalExpression("&&",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength)));}function checkObject(_ref124){var input=_ref124.input;var properties=_ref124.properties;var indexers=_ref124.indexers;var scope=_ref124.scope;function _ref35(_id51){if(!Node(_id51)){throw new TypeError('Function "checkObject" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id51));}return _id51;}if(input.type==='ObjectPattern'){return _ref35(checkObjectPattern({input:input,properties:properties,scope:scope}));}var propNames=[];var check=properties.length===0?checkIsObject({input:input}):properties.reduce(function(expr,prop,index){var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);propNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);var check=checkAnnotation(target,prop.value,scope);if(check){if(prop.optional){check=t.logicalExpression('||',checks.undefined({input:target}),check);}return t.logicalExpression("&&",expr,check);}else {return expr;}},checkNotNull({input:input}));if(indexers.length){return _ref35(indexers.reduceRight(function(expr,indexer){if(indexer.value.type==='AnyTypeAnnotation'){return expr;}var value=scope.generateUidIdentifier(indexer.id.name);var check=checkAnnotation(value,indexer.value,scope);var fixedKeys=t.arrayExpression(propNames);if(check){if(propNames.length){return t.logicalExpression('&&',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}else {return t.logicalExpression('&&',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}}else {return expr;}},check));}return _ref35(check);}function checkObjectPattern(_ref125){var input=_ref125.input;var properties=_ref125.properties;var scope=_ref125.scope;function _ref36(_id52){if(!(_id52==null||Node(_id52))){throw new TypeError('Function "checkObjectPattern" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id52));}return _id52;}var propNames=properties.reduce(function(names,prop){names[prop.key.name]=prop;return names;},{});var propChecks={};_input$properties=input.properties;if(!(_input$properties&&(typeof _input$properties[Symbol.iterator]==='function'||Array.isArray(_input$properties)))){throw new TypeError('Expected _input$properties to be iterable, got '+_inspect(_input$properties));}var _iteratorNormalCompletion9=true;var _didIteratorError9=false;var _iteratorError9=undefined;try{for(var _iterator9=_input$properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){var _input$properties;var item=_step9.value;var key=item.key;var _id121=item.value;var prop=propNames[key.name];if(!prop){continue;}var check=checkAnnotation(_id121,prop.value,scope);if(check){propChecks[key.name]=check;}}}catch(err){_didIteratorError9=true;_iteratorError9=err;}finally {try{if(!_iteratorNormalCompletion9&&_iterator9.return){_iterator9.return();}}finally {if(_didIteratorError9){throw _iteratorError9;}}}return _ref36(Object.keys(propChecks).reduce(function(last,name){var check=propChecks[name];if(last===null){return check;}else {return t.logicalExpression('&&',last,check);}},null));}function createTypeAliasChecks(path){function _ref37(_id53){if(!Node(_id53)){throw new TypeError('Function "createTypeAliasChecks" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id53));}return _id53;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.right;var input=t.identifier('input');var check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;declaration.savedTypeAnnotation=annotation;declaration.declarations[0].savedTypeAnnotation=annotation;return _ref37(declaration);}function createInterfaceChecks(path){function _ref38(_id54){if(!Node(_id54)){throw new TypeError('Function "createInterfaceChecks" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id54));}return _id54;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.body;var input=t.identifier('input');var check=node.extends.reduce(function(check,extender){return t.logicalExpression('&&',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));return check;},checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;return _ref38(declaration);}function checkAnnotation(input,annotation,scope){function _ref39(_id55){if(!(_id55==null||Node(_id55))){throw new TypeError('Function "checkAnnotation" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id55));}return _id55;}if(!Node(input)){throw new TypeError('Value of argument "input" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(input));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(!Scope(scope)){throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref39(checkAnnotation(input,annotation.typeAnnotation,scope));case 'TypeofTypeAnnotation':return _ref39(checks.typeof({input:input,annotation:annotation.argument,scope:scope}));case 'GenericTypeAnnotation':if(annotation.id.name==='Array'){return _ref39(checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Generator'&&!scope.hasBinding('Generator')){return _ref39(checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Iterable'&&!scope.hasBinding('Iterable')){return _ref39(checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Map'&&!scope.getBinding('Map')){return _ref39(checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Set'&&!scope.getBinding('Set')){return _ref39(checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='Function'){return _ref39(checks.function({input:input}));}else if(annotation.id.name==='Class'&&!scope.hasBinding('Class')){return _ref39(checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope}));}else if(annotation.id.name==='int8'&&!scope.hasBinding('int8')){return _ref39(checks.int8({input:input}));}else if(annotation.id.name==='uint8'&&!scope.hasBinding('uint8')){return _ref39(checks.uint8({input:input}));}else if(annotation.id.name==='int16'&&!scope.hasBinding('int16')){return _ref39(checks.int16({input:input}));}else if(annotation.id.name==='uint16'&&!scope.hasBinding('uint16')){return _ref39(checks.uint16({input:input}));}else if(annotation.id.name==='int32'&&!scope.hasBinding('int32')){return _ref39(checks.int32({input:input}));}else if(annotation.id.name==='uint32'&&!scope.hasBinding('uint32')){return _ref39(checks.uint32({input:input}));}else if(annotation.id.name==='float32'&&!scope.hasBinding('float32')){return _ref39(checks.float32({input:input}));}else if(annotation.id.name==='float64'&&!scope.hasBinding('float64')){return _ref39(checks.float64({input:input}));}else if(annotation.id.name==='double'&&!scope.hasBinding('double')){return _ref39(checks.double({input:input}));}else if(annotation.id.name==='Symbol'&&!scope.getBinding('Symbol')){return _ref39(checks.symbol({input:input}));}else if(isTypeChecker(annotation.id,scope)){return _ref39(checks.type({input:input,type:annotation.id}));}else if(isPolymorphicType(annotation.id,scope)){return;}else {return _ref39(checks.instanceof({input:input,type:createTypeExpression(annotation.id)}));}case 'TupleTypeAnnotation':return _ref39(checks.tuple({input:input,types:annotation.types,scope:scope}));case 'NumberTypeAnnotation':return _ref39(checks.number({input:input}));case 'NumericLiteralTypeAnnotation':return _ref39(checks.numericLiteral({input:input,annotation:annotation}));case 'BooleanTypeAnnotation':return _ref39(checks.boolean({input:input}));case 'BooleanLiteralTypeAnnotation':return _ref39(checks.booleanLiteral({input:input,annotation:annotation}));case 'StringTypeAnnotation':return _ref39(checks.string({input:input}));case 'StringLiteralTypeAnnotation':return _ref39(checks.stringLiteral({input:input,annotation:annotation}));case 'UnionTypeAnnotation':return _ref39(checks.union({input:input,types:annotation.types,scope:scope}));case 'IntersectionTypeAnnotation':return _ref39(checks.intersection({input:input,types:annotation.types,scope:scope}));case 'ObjectTypeAnnotation':return _ref39(checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope}));case 'ArrayTypeAnnotation':return _ref39(checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope}));case 'FunctionTypeAnnotation':return _ref39(checks.function({input:input,params:annotation.params,returnType:annotation.returnType}));case 'MixedTypeAnnotation':return _ref39(checks.mixed({input:input}));case 'AnyTypeAnnotation':case 'ExistentialTypeParam':return _ref39(checks.any({input:input}));case 'NullableTypeAnnotation':return _ref39(checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope}));case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return _ref39(checks.void({input:input}));}}function staticCheckAnnotation(path,annotation){function _ref40(_id56){if(!(_id56==null||typeof _id56==='boolean')){throw new TypeError('Function "staticCheckAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id56));}return _id56;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}var other=getAnnotation(path);switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref40(staticCheckAnnotation(path,annotation.typeAnnotation));case 'GenericTypeAnnotation':if(isTypeChecker(annotation.id,path.scope)){return _ref40(staticChecks.type({path:path,type:annotation.id}));}else if(isPolymorphicType(annotation.id,path.scope)){return;}else if(annotation.id.name==='Symbol'){return _ref40(staticChecks.symbol(path));}else {return _ref40(staticChecks.instanceof({path:path,annotation:annotation}));}}return _ref40(compareAnnotations(annotation,other));} /**
   * Get the type annotation for a given node.
   */function getAnnotation(path){function _ref41(_id57){if(!TypeAnnotation(_id57)){throw new TypeError('Function "getAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id57));}return _id57;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var annotation=void 0;try{annotation=getAnnotationShallow(path);}catch(e){if(e instanceof SyntaxError){throw e;}if(process.env.TYPECHECK_DEBUG){console.error(e.stack);}}while(annotation&&annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}return _ref41(annotation||t.anyTypeAnnotation());}function getAnnotationShallow(path){function _ref42(_id58){if(!(_id58==null||TypeAnnotation(_id58))){throw new TypeError('Function "getAnnotationShallow" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id58));}return _id58;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!path||!path.node){return _ref42(t.voidTypeAnnotation());}var node=path.node;var scope=path.scope;if(node.type==='TypeAlias'){return _ref42(node.right);}else if(node.type==='ClassProperty'&&node.typeAnnotation){return _ref42(getClassPropertyAnnotation(path));}else if(node.type==='ClassMethod'&&node.returnType){return _ref42(getClassMethodAnnotation(path));}else if(node.type==='ObjectProperty'&&node.typeAnnotation){return _ref42(getObjectPropertyAnnotation(path));}else if(node.type==='SpreadProperty'&&node.typeAnnotation){return _ref42(getSpreadPropertyAnnotation(path));}else if(node.type==='ObjectMethod'&&node.returnType){return _ref42(getObjectMethodAnnotation(path));}else if(!node.typeAnnotation&&!node.savedTypeAnnotation&&!node.returnType){switch(path.type){case 'Identifier':var binding=scope.getBinding(node.name);if(!binding||!binding.identifier){return _ref42(path.getTypeAnnotation());}var id=binding.identifier;if(binding.path.type==='ObjectPattern'){return _ref42(getObjectPatternAnnotation(binding.path,node.name));}if(id.savedTypeAnnotation){return _ref42(id.savedTypeAnnotation);}else if(id.returnType){return _ref42(id.returnType);}else if(id.typeAnnotation){return _ref42(id.typeAnnotation);}else if(isPolymorphicType(id,scope)){return _ref42(t.anyTypeAnnotation());}return _ref42(binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation());case 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':return _ref42(createLiteralTypeAnnotation(path));case 'CallExpression':var callee=path.get('callee');if(callee.type==='Identifier'){if(callee.name==='Symbol'){return _ref42(t.genericTypeAnnotation('Symbol'));}var fn=getFunctionForIdentifier(callee);if(fn){return getAnnotation(fn);}}break;case 'ThisExpression':return _ref42(getThisExpressionAnnotation(path));case 'AssignmentExpression':return _ref42(getAssignmentExpressionAnnotation(path));case 'MemberExpression':return getMemberExpressionAnnotation(path);case 'ArrayExpression':return getArrayExpressionAnnotation(path);case 'ObjectExpression':return getObjectExpressionAnnotation(path);case 'BinaryExpression':return getBinaryExpressionAnnotation(path);case 'LogicalExpression':return getLogicalExpressionAnnotation(path);case 'ConditionalExpression':return getConditionalExpressionAnnotation(path);case 'ObjectMethod':return _ref42(getObjectMethodAnnotation(path));case 'SpreadProperty':return _ref42(getSpreadPropertyAnnotation(path));case 'ObjectProperty':return _ref42(getObjectPropertyAnnotation(path));case 'ClassDeclaration':return _ref42(getClassDeclarationAnnotation(path));case 'ClassMethod':return _ref42(getClassMethodAnnotation(path));case 'ClassProperty':return _ref42(getClassPropertyAnnotation(path));default:return _ref42(path.getTypeAnnotation());}}return _ref42(node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation());}function createLiteralTypeAnnotation(path){function _ref43(_id59){if(!(_id59==null||TypeAnnotation(_id59))){throw new TypeError('Function "createLiteralTypeAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id59));}return _id59;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var annotation=void 0;if(path.isStringLiteral()){annotation=t.stringLiteralTypeAnnotation();}else if(path.isNumericLiteral()){annotation=t.numericLiteralTypeAnnotation();}else if(path.isBooleanLiteral()){annotation=t.booleanLiteralTypeAnnotation();}else {return _ref43(path.getTypeAnnotation());}annotation.value=path.node.value;return _ref43(annotation);}function getObjectPatternAnnotation(path,name){function _ref44(_id60){if(!(_id60==null||TypeAnnotation(_id60))){throw new TypeError('Function "getObjectPatternAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id60));}return _id60;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!(typeof name==='string')){throw new TypeError('Value of argument "name" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(name));}var annotation=keyByName(getAnnotation(path),name);var found=void 0;if(!path.node.properties){return;}_path$get4=path.get('properties');if(!(_path$get4&&(typeof _path$get4[Symbol.iterator]==='function'||Array.isArray(_path$get4)))){throw new TypeError('Expected _path$get4 to be iterable, got '+_inspect(_path$get4));}var _iteratorNormalCompletion10=true;var _didIteratorError10=false;var _iteratorError10=undefined;try{for(var _iterator10=_path$get4[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){var _path$get4;var prop=_step10.value;if(prop.node.value&&prop.node.value.name===name){found=prop.get('key');break;}else if(prop.node.key.type==='Identifier'&&prop.node.key.name===name){found=prop.get('key');break;}}}catch(err){_didIteratorError10=true;_iteratorError10=err;}finally {try{if(!_iteratorNormalCompletion10&&_iterator10.return){_iterator10.return();}}finally {if(_didIteratorError10){throw _iteratorError10;}}}if(!annotation||!found){return;}if(found.type==='Identifier'){annotation.value.authoritative=false;return _ref44(annotation.value);}}function keyByName(node,name){function _ref45(_id61){if(!(_id61==null||Node(_id61))){throw new TypeError('Function "keyByName" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id61));}return _id61;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(!(typeof name==='string')){throw new TypeError('Value of argument "name" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(name));}if(!node.properties){return;}_node$properties=node.properties;if(!(_node$properties&&(typeof _node$properties[Symbol.iterator]==='function'||Array.isArray(_node$properties)))){throw new TypeError('Expected _node$properties to be iterable, got '+_inspect(_node$properties));}var _iteratorNormalCompletion11=true;var _didIteratorError11=false;var _iteratorError11=undefined;try{for(var _iterator11=_node$properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){var _node$properties;var prop=_step11.value;if(prop.key&&prop.key.name===name){return _ref45(prop);}}}catch(err){_didIteratorError11=true;_iteratorError11=err;}finally {try{if(!_iteratorNormalCompletion11&&_iterator11.return){_iterator11.return();}}finally {if(_didIteratorError11){throw _iteratorError11;}}}}function valueByName(node,name){function _ref46(_id62){if(!(_id62==null||Node(_id62))){throw new TypeError('Function "valueByName" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id62));}return _id62;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(!(typeof name==='string')){throw new TypeError('Value of argument "name" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(name));}if(!node.properties){return;}_node$properties2=node.properties;if(!(_node$properties2&&(typeof _node$properties2[Symbol.iterator]==='function'||Array.isArray(_node$properties2)))){throw new TypeError('Expected _node$properties2 to be iterable, got '+_inspect(_node$properties2));}var _iteratorNormalCompletion12=true;var _didIteratorError12=false;var _iteratorError12=undefined;try{for(var _iterator12=_node$properties2[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){var _node$properties2;var prop=_step12.value;if(prop.value&&prop.value.name===name){return _ref46(prop);}}}catch(err){_didIteratorError12=true;_iteratorError12=err;}finally {try{if(!_iteratorNormalCompletion12&&_iterator12.return){_iterator12.return();}}finally {if(_didIteratorError12){throw _iteratorError12;}}}}function getSpreadPropertyAnnotation(path){function _ref47(_id63){if(!(_id63==null||TypeAnnotation(_id63))){throw new TypeError('Function "getSpreadPropertyAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id63));}return _id63;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){annotation=getAnnotation(path.get('argument'));}return _ref47(annotation);}function getObjectPropertyAnnotation(path){function _ref48(_id64){if(!(_id64==null||TypeAnnotation(_id64))){throw new TypeError('Function "getObjectPropertyAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id64));}return _id64;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){if(node.value){if(node.value.typeAnnotation||node.value.savedTypeAnnotation){annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}else if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){annotation=t[node.value.type](node.value.value);}else {annotation=t.anyTypeAnnotation();}}else {annotation=t.anyTypeAnnotation();}}return _ref48(t.objectTypeProperty(node.key,annotation));}function getObjectMethodAnnotation(path){function _ref49(_id65){if(!(_id65==null||TypeAnnotation(_id65))){throw new TypeError('Function "getObjectMethodAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id65));}return _id65;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;return _ref49(t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation())));}function getThisExpressionAnnotation(path){function _ref50(_id66){if(!(_id66==null||TypeAnnotation(_id66))){throw new TypeError('Function "getThisExpressionAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id66));}return _id66;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var parent=path.parentPath;loop: while(parent){switch(parent.type){case 'ClassDeclaration':return getAnnotation(parent);case 'ClassBody':return getAnnotation(parent.parentPath);case 'ClassMethod':case 'ClassProperty':return getAnnotation(parent.parentPath.parentPath);case 'ObjectProperty':return getAnnotation(parent.parentPath);case 'ObjectMethod':return getAnnotation(parent.parentPath);case 'FunctionExpression':if(parent.parentPath.type==='ObjectProperty'){return getAnnotation(parent.parentPath.parentPath);}break loop;case 'ArrowFunctionExpression':parent=parent.parentPath;continue;}if(parent.isFunction()){break;}parent=parent.parentPath;}return _ref50(t.objectTypeAnnotation([]));}function getClassDeclarationAnnotation(path){function _ref51(_id67){if(!(_id67==null||TypeAnnotation(_id67))){throw new TypeError('Function "getClassDeclarationAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id67));}return _id67;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var body=path.get('body').get('body').map(getAnnotation).filter(function(annotation){return annotation&&annotation.type!=='AnyTypeAnnotation';});return _ref51(t.objectTypeAnnotation(body));}function getAssignmentExpressionAnnotation(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(path.node.operator==='='){return getAnnotation(path.get('right'));}}function getClassPropertyAnnotation(path){function _ref53(_id69){if(!(_id69==null||TypeAnnotation(_id69))){throw new TypeError('Function "getClassPropertyAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id69));}return _id69;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;if(node.computed){return;}var annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());return _ref53(t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation()));}function getClassMethodAnnotation(path){function _ref54(_id70){if(!(_id70==null||TypeAnnotation(_id70))){throw new TypeError('Function "getClassMethodAnnotation" return value violates contract.\n\nExpected:\n?TypeAnnotation\n\nGot:\n'+_inspect(_id70));}return _id70;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;if(node.computed){return;}if(node.kind==='get'){return _ref54(t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}else if(node.kind==='set'){return _ref54(t.objectTypeProperty(node.key,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}).shift()||t.anyTypeAnnotation()));}else {return _ref54(t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation())));}}function getBinaryExpressionAnnotation(path){function _ref55(_id71){if(!TypeAnnotation(_id71)){throw new TypeError('Function "getBinaryExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id71));}return _id71;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;if(isBooleanExpression(node)){return _ref55(t.booleanTypeAnnotation());}else {return _ref55(t.anyTypeAnnotation());}}function getLogicalExpressionAnnotation(path){function _ref56(_id72){if(!TypeAnnotation(_id72)){throw new TypeError('Function "getLogicalExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id72));}return _id72;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;if(isBooleanExpression(node)){return _ref56(t.booleanTypeAnnotation());}else {var left=path.get('left');var right=path.get('right');switch(node.operator){case '&&':case '||':var _ref126=[getAnnotation(left),getAnnotation(right)];left=_ref126[0];right=_ref126[1];if(t.isUnionTypeAnnotation(left)){if(t.isUnionTypeAnnotation(right)){return _ref56(t.unionTypeAnnotation(left.types.concat(right.types)));}else {return _ref56(t.unionTypeAnnotation(left.types.concat(right)));}}else {return _ref56(t.unionTypeAnnotation([left,right]));}}return _ref56(t.anyTypeAnnotation());}}function getConditionalExpressionAnnotation(path){function _ref57(_id73){if(!TypeAnnotation(_id73)){throw new TypeError('Function "getConditionalExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id73));}return _id73;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;var consequent=getAnnotation(path.get('consequent'));var alternate=getAnnotation(path.get('alternate'));if(t.isUnionTypeAnnotation(consequent)){if(t.isUnionTypeAnnotation(alternate)){return _ref57(t.unionTypeAnnotation(consequent.types.concat(alternate.types)));}else {return _ref57(t.unionTypeAnnotation(consequent.types.concat(alternate)));}}else {return _ref57(t.unionTypeAnnotation([consequent,alternate]));}}function getArrayExpressionAnnotation(path){function _ref58(_id74){if(!TypeAnnotation(_id74)){throw new TypeError('Function "getArrayExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id74));}return _id74;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}return _ref58(t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation))));}function getObjectExpressionAnnotation(path){function _ref59(_id75){if(!TypeAnnotation(_id75)){throw new TypeError('Function "getObjectExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id75));}return _id75;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var annotation=t.objectTypeAnnotation(path.get('properties').filter(function(prop){return !prop.node.computed;}).map(getAnnotation).reduce(function(properties,prop){if(t.isObjectTypeProperty(prop)){properties.push(prop);}else if(t.isObjectTypeAnnotation(prop)){properties.push.apply(properties,_toConsumableArray(prop.properties));}return properties;},[]).filter(function(annotation){return !t.isAnyTypeAnnotation(annotation.value);}));return _ref59(annotation);}function getMemberExpressionAnnotation(path){function _ref60(_id76){if(!TypeAnnotation(_id76)){throw new TypeError('Function "getMemberExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id76));}return _id76;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(path.node.computed){return _ref60(getComputedMemberExpressionAnnotation(path));}var stack=[];var target=path;while(target.isMemberExpression()){stack.push(target);if(target.node.computed){break;}target=target.get('object');}var objectAnnotation=stack.reduceRight(function(last,target){var annotation=last;if(annotation==null){if(stack.length===1){annotation=getAnnotation(target.get('object'));}else {return getAnnotation(target);}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'NullableTypeAnnotation':case 'TypeAnnotation':annotation=annotation.typeAnnotation;}if(annotation.type==='GenericTypeAnnotation'){var typeChecker=getTypeChecker(annotation.id,path.scope);if(typeChecker){annotation=getAnnotation(typeChecker);}else if(isPolymorphicType(annotation.id,path.scope)){annotation=t.anyTypeAnnotation();}else {var binding=path.scope.getBinding(annotation.id.name);if(binding){annotation=getAnnotation(binding.path);}}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'ObjectTypeAnnotation':var id=target.get('property').node;_ref61=annotation.properties||[];if(!(_ref61&&(typeof _ref61[Symbol.iterator]==='function'||Array.isArray(_ref61)))){throw new TypeError('Expected _ref61 to be iterable, got '+_inspect(_ref61));}var _iteratorNormalCompletion13=true;var _didIteratorError13=false;var _iteratorError13=undefined;try{for(var _iterator13=_ref61[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){var _ref61;var _step13$value=_step13.value;var key=_step13$value.key;var value=_step13$value.value;if(key.name===id.name){return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}}}catch(err){_didIteratorError13=true;_iteratorError13=err;}finally {try{if(!_iteratorNormalCompletion13&&_iterator13.return){_iterator13.return();}}finally {if(_didIteratorError13){throw _iteratorError13;}}}}return t.anyTypeAnnotation();},null);return _ref60(objectAnnotation||path.getTypeAnnotation());}function getComputedMemberExpressionAnnotation(path){function _ref62(_id77){if(!TypeAnnotation(_id77)){throw new TypeError('Function "getComputedMemberExpressionAnnotation" return value violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(_id77));}return _id77;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var object=path.get('object');var property=path.get('property');var objectAnnotation=getAnnotation(object);if(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){objectAnnotation=objectAnnotation.typeAnnotation;}var propertyAnnotation=getAnnotation(property);if(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){propertyAnnotation=propertyAnnotation.typeAnnotation;}var _property$evaluate=property.evaluate();var confident=_property$evaluate.confident;var value=_property$evaluate.value;if(!confident){return _ref62(path.getTypeAnnotation());}switch(objectAnnotation.type){case 'TupleTypeAnnotation':if(objectAnnotation.types.length===0){break;}else if(typeof value==='number'){if(!objectAnnotation.types[value]){throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}return _ref62(objectAnnotation.types[value]);}else {throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}break;}return _ref62(path.getTypeAnnotation());}function getFunctionForIdentifier(path){function _ref63(_id78){if(!(typeof _id78==='boolean'||Node(_id78))){throw new TypeError('Function "getFunctionForIdentifier" return value violates contract.\n\nExpected:\nbool | Node\n\nGot:\n'+_inspect(_id78));}return _id78;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(path.type!=='Identifier'){return false;}else if(isTypeChecker(path.node,path.scope)||isPolymorphicType(path.node,path.scope)){return false;}var ref=path.scope.getBinding(path.node.name);if(!ref){return false;}return _ref63(t.isFunction(ref.path.parent)&&ref.path.parentPath);} /**
   * Determine whether the given annotation is for an array.
   */function isStrictlyArrayAnnotation(annotation){function _ref64(_id79){if(!(_id79==null||typeof _id79==='boolean')){throw new TypeError('Function "isStrictlyArrayAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id79));}return _id79;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return _ref64(isStrictlyArrayAnnotation(annotation.typeAnnotation));case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':return _ref64(annotation.types.every(isStrictlyArrayAnnotation));default:return false;}}function compareMaybeUnion(annotation,comparator){function _ref65(_id80){if(!(_id80==null||typeof _id80==='boolean')){throw new TypeError('Function "compareMaybeUnion" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id80));}return _id80;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(!(typeof comparator==='function')){throw new TypeError('Value of argument "comparator" violates contract.\n\nExpected:\n(TypeAnnotation) => ?bool\n\nGot:\n'+_inspect(comparator));}var falseCount=0;_annotation$types=annotation.types;if(!(_annotation$types&&(typeof _annotation$types[Symbol.iterator]==='function'||Array.isArray(_annotation$types)))){throw new TypeError('Expected _annotation$types to be iterable, got '+_inspect(_annotation$types));}var _iteratorNormalCompletion14=true;var _didIteratorError14=false;var _iteratorError14=undefined;try{for(var _iterator14=_annotation$types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){var _annotation$types;var _type6=_step14.value;var result=comparator(_type6);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError14=true;_iteratorError14=err;}finally {try{if(!_iteratorNormalCompletion14&&_iterator14.return){_iterator14.return();}}finally {if(_didIteratorError14){throw _iteratorError14;}}}if(falseCount===annotation.types.length){return false;}else {return _ref65(null);}} /**
   * Returns `true` if the annotation is compatible with a number,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeNumberAnnotation(annotation){function _ref66(_id81){if(!(_id81==null||typeof _id81==='boolean')){throw new TypeError('Function "maybeNumberAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id81));}return _id81;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref66(maybeNumberAnnotation(annotation.typeAnnotation));case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return _ref66(null);}case 'UnionTypeAnnotation':return _ref66(compareMaybeUnion(annotation,maybeNumberAnnotation));case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref66(null);default:return false;}} /**
   * Returns `true` if the annotation is compatible with a string,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeStringAnnotation(annotation){function _ref67(_id82){if(!(_id82==null||typeof _id82==='boolean')){throw new TypeError('Function "maybeStringAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id82));}return _id82;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref67(maybeStringAnnotation(annotation.typeAnnotation));case 'StringTypeAnnotation':case 'StringLiteral':return true;case 'StringLiteralTypeAnnotation':return _ref67(null);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;default:return _ref67(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types2=annotation.types;if(!(_annotation$types2&&(typeof _annotation$types2[Symbol.iterator]==='function'||Array.isArray(_annotation$types2)))){throw new TypeError('Expected _annotation$types2 to be iterable, got '+_inspect(_annotation$types2));}var _iteratorNormalCompletion15=true;var _didIteratorError15=false;var _iteratorError15=undefined;try{for(var _iterator15=_annotation$types2[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){var _annotation$types2;var _type7=_step15.value;var result=maybeStringAnnotation(_type7);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError15=true;_iteratorError15=err;}finally {try{if(!_iteratorNormalCompletion15&&_iterator15.return){_iterator15.return();}}finally {if(_didIteratorError15){throw _iteratorError15;}}}if(falseCount===annotation.types.length){return false;}else {return _ref67(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref67(null);default:return false;}} /**
   * Returns `true` if the annotation is compatible with a symbol,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeSymbolAnnotation(annotation){function _ref68(_id83){if(!(_id83==null||typeof _id83==='boolean')){throw new TypeError('Function "maybeSymbolAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id83));}return _id83;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref68(maybeSymbolAnnotation(annotation.typeAnnotation));case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Symbol':return true;default:return _ref68(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types3=annotation.types;if(!(_annotation$types3&&(typeof _annotation$types3[Symbol.iterator]==='function'||Array.isArray(_annotation$types3)))){throw new TypeError('Expected _annotation$types3 to be iterable, got '+_inspect(_annotation$types3));}var _iteratorNormalCompletion16=true;var _didIteratorError16=false;var _iteratorError16=undefined;try{for(var _iterator16=_annotation$types3[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){var _annotation$types3;var _type8=_step16.value;var result=maybeSymbolAnnotation(_type8);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError16=true;_iteratorError16=err;}finally {try{if(!_iteratorNormalCompletion16&&_iterator16.return){_iterator16.return();}}finally {if(_didIteratorError16){throw _iteratorError16;}}}if(falseCount===annotation.types.length){return false;}else {return _ref68(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref68(null);default:return false;}} /**
   * Returns `true` if the annotation is compatible with a boolean,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeBooleanAnnotation(annotation){function _ref69(_id84){if(!(_id84==null||typeof _id84==='boolean')){throw new TypeError('Function "maybeBooleanAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id84));}return _id84;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref69(maybeBooleanAnnotation(annotation.typeAnnotation));case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':return false;default:return _ref69(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types4=annotation.types;if(!(_annotation$types4&&(typeof _annotation$types4[Symbol.iterator]==='function'||Array.isArray(_annotation$types4)))){throw new TypeError('Expected _annotation$types4 to be iterable, got '+_inspect(_annotation$types4));}var _iteratorNormalCompletion17=true;var _didIteratorError17=false;var _iteratorError17=undefined;try{for(var _iterator17=_annotation$types4[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){var _annotation$types4;var _type9=_step17.value;var result=maybeBooleanAnnotation(_type9);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError17=true;_iteratorError17=err;}finally {try{if(!_iteratorNormalCompletion17&&_iterator17.return){_iterator17.return();}}finally {if(_didIteratorError17){throw _iteratorError17;}}}if(falseCount===annotation.types.length){return false;}else {return _ref69(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref69(null);default:return false;}} /**
   * Returns `true` if the annotation is compatible with a function,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeFunctionAnnotation(annotation){function _ref70(_id85){if(!(_id85==null||typeof _id85==='boolean')){throw new TypeError('Function "maybeFunctionAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id85));}return _id85;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref70(maybeFunctionAnnotation(annotation.typeAnnotation));case 'FunctionTypeAnnotation':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return _ref70(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types5=annotation.types;if(!(_annotation$types5&&(typeof _annotation$types5[Symbol.iterator]==='function'||Array.isArray(_annotation$types5)))){throw new TypeError('Expected _annotation$types5 to be iterable, got '+_inspect(_annotation$types5));}var _iteratorNormalCompletion18=true;var _didIteratorError18=false;var _iteratorError18=undefined;try{for(var _iterator18=_annotation$types5[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){var _annotation$types5;var _type10=_step18.value;var result=maybeFunctionAnnotation(_type10);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError18=true;_iteratorError18=err;}finally {try{if(!_iteratorNormalCompletion18&&_iterator18.return){_iterator18.return();}}finally {if(_didIteratorError18){throw _iteratorError18;}}}if(falseCount===annotation.types.length){return false;}else {return _ref70(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref70(null);default:return false;}} /**
   * Returns `true` if the annotation is compatible with an undefined or null type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeNullableAnnotation(annotation){function _ref71(_id86){if(!(_id86==null||typeof _id86==='boolean')){throw new TypeError('Function "maybeNullableAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id86));}return _id86;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return _ref71(maybeNullableAnnotation(annotation.typeAnnotation));case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Generator':if(annotation.typeParameters&&annotation.typeParameters.params.length>1){return _ref71(maybeNullableAnnotation(annotation.typeParameters.params[1]));}else {return _ref71(null);}default:return _ref71(null);}case 'UnionTypeAnnotation':var falseCount=0;_annotation$types6=annotation.types;if(!(_annotation$types6&&(typeof _annotation$types6[Symbol.iterator]==='function'||Array.isArray(_annotation$types6)))){throw new TypeError('Expected _annotation$types6 to be iterable, got '+_inspect(_annotation$types6));}var _iteratorNormalCompletion19=true;var _didIteratorError19=false;var _iteratorError19=undefined;try{for(var _iterator19=_annotation$types6[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){var _annotation$types6;var _type11=_step19.value;var result=maybeNullableAnnotation(_type11);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError19=true;_iteratorError19=err;}finally {try{if(!_iteratorNormalCompletion19&&_iterator19.return){_iterator19.return();}}finally {if(_didIteratorError19){throw _iteratorError19;}}}if(falseCount===annotation.types.length){return false;}else {return _ref71(null);}default:return false;}} /**
   * Returns `true` if the annotation is compatible with an object type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeInstanceOfAnnotation(annotation,expected,typeParameters){function _ref72(_id87){if(!(_id87==null||typeof _id87==='boolean')){throw new TypeError('Function "maybeInstanceOfAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id87));}return _id87;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(!Identifier(expected)){throw new TypeError('Value of argument "expected" violates contract.\n\nExpected:\nIdentifier\n\nGot:\n'+_inspect(expected));}if(!(Array.isArray(typeParameters)&&typeParameters.every(function(item){return TypeAnnotation(item);}))){throw new TypeError('Value of argument "typeParameters" violates contract.\n\nExpected:\nTypeAnnotation[]\n\nGot:\n'+_inspect(typeParameters));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref72(maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters));case 'GenericTypeAnnotation':if(annotation.id.name===expected.name){if(typeParameters.length===0){return true;}if(annotation.typeParameters&&annotation.typeParameters.params.length){var trueCount=0;var nullCount=0;for(var i=0;i<typeParameters.length&&i<annotation.typeParameters.params.length;i++){var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);if(result===false){return false;}else if(result===true){trueCount++;}else {nullCount++;}}return trueCount>0&&nullCount===0?true:null;}}return _ref72(null);case 'UnionTypeAnnotation':var falseCount=0;_annotation$types7=annotation.types;if(!(_annotation$types7&&(typeof _annotation$types7[Symbol.iterator]==='function'||Array.isArray(_annotation$types7)))){throw new TypeError('Expected _annotation$types7 to be iterable, got '+_inspect(_annotation$types7));}var _iteratorNormalCompletion20=true;var _didIteratorError20=false;var _iteratorError20=undefined;try{for(var _iterator20=_annotation$types7[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){var _annotation$types7;var _type12=_step20.value;var _result=maybeInstanceOfAnnotation(_type12,expected,typeParameters);if(_result===true){return true;}else if(_result===false){falseCount++;}}}catch(err){_didIteratorError20=true;_iteratorError20=err;}finally {try{if(!_iteratorNormalCompletion20&&_iterator20.return){_iterator20.return();}}finally {if(_didIteratorError20){throw _iteratorError20;}}}if(falseCount===annotation.types.length){return false;}else {return _ref72(null);}case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){return false;}else {return _ref72(null);}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){return false;}else {return _ref72(null);}case 'FunctionTypeAnnotation':if(expected.name==='Function'){return true;}else {return _ref72(null);}default:return _ref72(null);}} /**
   * Returns `true` if the annotation is compatible with an array,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeArrayAnnotation(annotation){function _ref73(_id88){if(!(_id88==null||typeof _id88==='boolean')){throw new TypeError('Function "maybeArrayAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id88));}return _id88;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref73(maybeArrayAnnotation(annotation.typeAnnotation));case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':var falseCount=0;_annotation$types8=annotation.types;if(!(_annotation$types8&&(typeof _annotation$types8[Symbol.iterator]==='function'||Array.isArray(_annotation$types8)))){throw new TypeError('Expected _annotation$types8 to be iterable, got '+_inspect(_annotation$types8));}var _iteratorNormalCompletion21=true;var _didIteratorError21=false;var _iteratorError21=undefined;try{for(var _iterator21=_annotation$types8[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){var _annotation$types8;var _type13=_step21.value;var result=maybeArrayAnnotation(_type13);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError21=true;_iteratorError21=err;}finally {try{if(!_iteratorNormalCompletion21&&_iterator21.return){_iterator21.return();}}finally {if(_didIteratorError21){throw _iteratorError21;}}}if(falseCount===annotation.types.length){return false;}else {return _ref73(null);}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref73(null);default:return false;}} /**
   * Returns `true` if the annotation is compatible with an iterable,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeIterableAnnotation(annotation){function _ref74(_id89){if(!(_id89==null||typeof _id89==='boolean')){throw new TypeError('Function "maybeIterableAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id89));}return _id89;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref74(maybeIterableAnnotation(annotation.typeAnnotation));case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Iterable'?true:null;case 'UnionTypeAnnotation':var falseCount=0;_annotation$types9=annotation.types;if(!(_annotation$types9&&(typeof _annotation$types9[Symbol.iterator]==='function'||Array.isArray(_annotation$types9)))){throw new TypeError('Expected _annotation$types9 to be iterable, got '+_inspect(_annotation$types9));}var _iteratorNormalCompletion22=true;var _didIteratorError22=false;var _iteratorError22=undefined;try{for(var _iterator22=_annotation$types9[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){var _annotation$types9;var _type14=_step22.value;var result=maybeIterableAnnotation(_type14);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError22=true;_iteratorError22=err;}finally {try{if(!_iteratorNormalCompletion22&&_iterator22.return){_iterator22.return();}}finally {if(_didIteratorError22){throw _iteratorError22;}}}if(falseCount===annotation.types.length){return false;}else {return _ref74(null);}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return false;default:return _ref74(null);}} /**
   * Returns `true` if the annotation is compatible with a tuple,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeTupleAnnotation(annotation){function _ref75(_id90){if(!(_id90==null||typeof _id90==='boolean')){throw new TypeError('Function "maybeTupleAnnotation" return value violates contract.\n\nExpected:\n?bool\n\nGot:\n'+_inspect(_id90));}return _id90;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return _ref75(maybeTupleAnnotation(annotation.typeAnnotation));case 'TupleTypeAnnotation':return true;case 'UnionTypeAnnotation':var falseCount=0;_annotation$types10=annotation.types;if(!(_annotation$types10&&(typeof _annotation$types10[Symbol.iterator]==='function'||Array.isArray(_annotation$types10)))){throw new TypeError('Expected _annotation$types10 to be iterable, got '+_inspect(_annotation$types10));}var _iteratorNormalCompletion23=true;var _didIteratorError23=false;var _iteratorError23=undefined;try{for(var _iterator23=_annotation$types10[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){var _annotation$types10;var _type15=_step23.value;var result=maybeTupleAnnotation(_type15);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError23=true;_iteratorError23=err;}finally {try{if(!_iteratorNormalCompletion23&&_iterator23.return){_iterator23.return();}}finally {if(_didIteratorError23){throw _iteratorError23;}}}if(falseCount===annotation.types.length){return false;}else {return _ref75(null);}case 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return _ref75(null);default:return false;}}function humanReadableType(annotation){function _ref76(_id91){if(!(typeof _id91==='string')){throw new TypeError('Function "humanReadableType" return value violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(_id91));}return _id91;}if(!(Node(annotation)||TypeAnnotation(annotation))){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nNode | TypeAnnotation\n\nGot:\n'+_inspect(annotation));}switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return _ref76(humanReadableType(annotation.typeAnnotation));case 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet
return '('+annotation.params.map(humanReadableType).join(', ')+') => '+humanReadableType(annotation.returnType);case 'GenericTypeAnnotation':var path=getNodePath(annotation);var checker=path&&getTypeChecker(annotation.id,path.scope);if(checker&&checker.node.savedTypeAnnotation){return _ref76(humanReadableType(checker.node.savedTypeAnnotation));}else {return _ref76((0,_babelGenerator2.default)(annotation).code);}default:return _ref76((0,_babelGenerator2.default)(annotation).code);}} /**
   * Get the path directly from a node.
   */function getNodePath(node){function _ref77(_id92){if(!(_id92==null||NodePath(_id92))){throw new TypeError('Function "getNodePath" return value violates contract.\n\nExpected:\n?NodePath\n\nGot:\n'+_inspect(_id92));}return _id92;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(node._paths&&node._paths.length){return _ref77(node._paths[0]);}else {return _ref77(null);}}function getTypeChecker(id,scope){function _ref78(_id93){if(!(NodePath(_id93)||_id93===false)){throw new TypeError('Function "getTypeChecker" return value violates contract.\n\nExpected:\nNodePath | false\n\nGot:\n'+_inspect(_id93));}return _id93;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}var checker=scope.getData('typechecker:'+id.name);if(checker){return _ref78(checker);}return false;}function isTypeChecker(id,scope){function _ref79(_id94){if(!(typeof _id94==='boolean')){throw new TypeError('Function "isTypeChecker" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id94));}return _id94;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}return _ref79(scope.getData('typechecker:'+id.name)!==undefined);}function isPolymorphicType(id,scope){function _ref80(_id95){if(!(typeof _id95==='boolean')){throw new TypeError('Function "isPolymorphicType" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id95));}return _id95;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}return _ref80(scope.getData('typeparam:'+id.name)!==undefined);}function getPolymorphicType(id,scope){function _ref81(_id96){if(!(_id96==null||Node(_id96))){throw new TypeError('Function "getPolymorphicType" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id96));}return _id96;}if(!(Identifier(id)||QualifiedTypeIdentifier(id))){throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | QualifiedTypeIdentifier\n\nGot:\n'+_inspect(id));}if(!Scope(scope)){throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}var path=scope.getData('typeparam:'+id.name);if(path){return _ref81(path.node);}}function collectParamChecks(path,context){function _ref82(_id97){if(!(Array.isArray(_id97)&&_id97.every(function(item){return Node(item);}))){throw new TypeError('Function "collectParamChecks" return value violates contract.\n\nExpected:\nNode[]\n\nGot:\n'+_inspect(_id97));}return _id97;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}return _ref82(path.get('params').map(function(param){var node=param.node;if(node.type==='AssignmentPattern'){if(node.left.typeAnnotation){return createDefaultParamGuard(param,context);}}else if(node.type==='RestElement'){if(node.typeAnnotation){return createRestParamGuard(param,context);}}else if(node.typeAnnotation){return createParamGuard(param,context);}}).filter(identity));}function createParamGuard(path,context){function _ref83(_id98){if(!(_id98==null||Node(_id98))){throw new TypeError('Function "createParamGuard" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id98));}return _id98;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var node=path.node;var scope=path.scope;node.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;var checkable=void 0;if(node.type==='ObjectPattern'){node.name=path.key;checkable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}else {checkable=node;}var check=checkAnnotation(checkable,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}var message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);return _ref83(guard({check:check,message:message}));}function createDefaultParamGuard(path,context){function _ref84(_id99){if(!(_id99==null||Node(_id99))){throw new TypeError('Function "createDefaultParamGuard" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id99));}return _id99;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var node=path.node;var scope=path.scope;var id=node.left;var value=node.right;var ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument "'+id.name+'".',id.typeAnnotation,getAnnotation(path.get('right'))));}return _ref84(createParamGuard(path.get('left'),context));}function createRestParamGuard(path,context){function _ref85(_id100){if(!(_id100==null||Node(_id100))){throw new TypeError('Function "createRestParamGuard" return value violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(_id100));}return _id100;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var node=path.node;var scope=path.scope;var id=node.argument;id.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;if(isStrictlyArrayAnnotation(node.typeAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument "'+id.name+'".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}var check=checkAnnotation(id,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:id}),check);}var message=paramTypeErrorMessage(id,context,node.typeAnnotation);return _ref85(guard({check:check,message:message}));}function returnTypeErrorMessage(path,fn,id,context){function _ref86(_id101){if(!Node(_id101)){throw new TypeError('Function "returnTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id101));}return _id101;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(!Node(fn)){throw new TypeError('Value of argument "fn" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(fn));}if(!(id==null||Identifier(id)||Literal(id))){throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\n?Identifier | Literal\n\nGot:\n'+_inspect(id));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var node=path.node;var scope=path.scope;var name=fn.id?fn.id.name:'';var annotation=fn.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(fn.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}var message='Function '+(name?'"'+name+'" ':'')+'return value violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return _ref86(t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined')));}function yieldTypeErrorMessage(fn,annotation,id,context){function _ref87(_id102){if(!Node(_id102)){throw new TypeError('Function "yieldTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id102));}return _id102;}if(!Node(fn)){throw new TypeError('Value of argument "fn" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(fn));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(!(Identifier(id)||Literal(id))){throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | Literal\n\nGot:\n'+_inspect(id));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var name=fn.id?fn.id.name:'';var message='Function '+(name?'"'+name+'" ':'')+'yielded an invalid value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return _ref87(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id})));}function yieldNextTypeErrorMessage(fn,annotation,id,context){function _ref88(_id103){if(!Node(_id103)){throw new TypeError('Function "yieldNextTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id103));}return _id103;}if(!Node(fn)){throw new TypeError('Value of argument "fn" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(fn));}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(!(Identifier(id)||Literal(id))){throw new TypeError('Value of argument "id" violates contract.\n\nExpected:\nIdentifier | Literal\n\nGot:\n'+_inspect(id));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var name=fn.id?fn.id.name:'';var message='Generator '+(name?'"'+name+'" ':'')+'received an invalid next value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return _ref88(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id})));}function paramTypeErrorMessage(node,context){var typeAnnotation=arguments.length<=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];function _ref89(_id104){if(!Node(_id104)){throw new TypeError('Function "paramTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id104));}return _id104;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}if(!TypeAnnotation(typeAnnotation)){throw new TypeError('Value of argument "typeAnnotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(typeAnnotation));}var name=node.name;if(node.type==='MemberExpression'&&node.object.name==='arguments'){name=node.property.value;}var message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\n\nExpected:\n'+humanReadableType(typeAnnotation)+'\n\nGot:\n';return _ref89(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node})));}function varTypeErrorMessage(node,context){function _ref90(_id105){if(!Node(_id105)){throw new TypeError('Function "varTypeErrorMessage" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id105));}return _id105;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var annotation=node.typeAnnotation;if(!TypeAnnotation(annotation)){throw new TypeError('Value of variable "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(node.type==='Identifier'){var _name3=node.name;var message='Value of variable "'+_name3+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return _ref90(t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node})));}else {var _message='Value of "'+humanReadableType(node)+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return _ref90(t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node})));}} /**
   * Create a React property validator
   */function generatePropType(annotation,scope,context){if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(!Scope(scope)){throw new TypeError('Value of argument "scope" violates contract.\n\nExpected:\nScope\n\nGot:\n'+_inspect(scope));}if(!VisitorContext(context)){throw new TypeError('Value of argument "context" violates contract.\n\nExpected:\nVisitorContext\n\nGot:\n'+_inspect(context));}var prop=t.identifier('prop');var check=checkAnnotation(prop,annotation,scope);if(check){return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}else {return t.functionExpression(null,[],t.blockStatement([]));}} /**
   * Determine whether the given node can produce purely boolean results.
   */function isBooleanExpression(node){if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(node.type==='BinaryExpression'&&BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)>-1){return true;}else if(node.type==='LogicalExpression'){return isBooleanExpression(node.left)&&isBooleanExpression(node.right);}else {return false;}} /**
   * Convert type specifier to expression.
   */function createTypeExpression(node){function _ref91(_id106){if(!(_id106 instanceof Object)){throw new TypeError('Function "createTypeExpression" return value violates contract.\n\nExpected:\nObject\n\nGot:\n'+_inspect(_id106));}return _id106;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(node.type=='Identifier'){return _ref91(node);}else if(node.type=='QualifiedTypeIdentifier'){return _ref91(t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id)));}throw this.errorWithNode('Unsupported type: '+node.type);} /**
   * Get name of a type as a string.
   */function getTypeName(node){function _ref92(_id107){if(!(typeof _id107==='string')){throw new TypeError('Function "getTypeName" return value violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(_id107));}return _id107;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}if(node.type=='Identifier'){return _ref92(node.name);}else if(node.type=='QualifiedTypeIdentifier'){return _ref92(getTypeName(node.qualification)+'.'+getTypeName(node.id));}throw this.errorWithNode('Unsupported type: '+node.type);} /**
   * Union two arrays.
   */function union(arr1,arr2){if(!Array.isArray(arr1)){throw new TypeError('Value of argument "arr1" violates contract.\n\nExpected:\nArray\n\nGot:\n'+_inspect(arr1));}if(!Array.isArray(arr2)){throw new TypeError('Value of argument "arr2" violates contract.\n\nExpected:\nArray\n\nGot:\n'+_inspect(arr2));}for(var i=0;i<arr2.length;i++){var item=arr2[i];if(arr1.indexOf(item)===-1){arr1.push(item);}}return arr1;} /**
   * Determine whether the given annotation allows any value.
   */function allowsAny(annotation){function _ref94(_id109){if(!(typeof _id109==='boolean')){throw new TypeError('Function "allowsAny" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id109));}return _id109;}if(!TypeAnnotation(annotation)){throw new TypeError('Value of argument "annotation" violates contract.\n\nExpected:\nTypeAnnotation\n\nGot:\n'+_inspect(annotation));}if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){return _ref94(allowsAny(annotation.typeAnnotation));}else if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){return true;}else if(annotation.type==='UnionTypeAnnotation'){return _ref94(annotation.types.some(allowsAny));}else {return false;}} /**
   * Determine whether a given node is nully (null or undefined).
   */function isNodeNully(node){if(!(node==null||Node(node))){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\n?Node\n\nGot:\n'+_inspect(node));}if(node==null){return true;}else if(node.type==='Identifier'&&node.name==='undefined'){return true;}else if(node.type==='Literal'&&node.value===null){return true;}else if(node.type==='UnaryExpression'&&node.operator==='void'){return true;}else {return false;}} /**
   * Determine whether the file should be checked
   */function mustCheckFile(path,opts){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(path.node.leadingComments&&path.node.leadingComments.length){return opts.only&&!skipEnvironment(path.node.leadingComments,opts);}return false;} /**
   * Determine whether the file should be skipped, based on the comments attached to the given node.
   */function maybeSkipFile(path,opts){function _ref97(_id112){if(!(typeof _id112==='boolean')){throw new TypeError('Function "maybeSkipFile" return value violates contract.\n\nExpected:\nbool\n\nGot:\n'+_inspect(_id112));}return _id112;}if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}if(path.node.leadingComments&&path.node.leadingComments.length){if(skipEnvironment(path.node.leadingComments,opts)){return true;}return _ref97(path.node.leadingComments.some(function(comment){return PRAGMA_IGNORE_FILE.test(comment.value);}));}return false;} /**
   * Maybe skip the given path if it has a relevant pragma.
   */function maybeSkip(path){if(!NodePath(path)){throw new TypeError('Value of argument "path" violates contract.\n\nExpected:\nNodePath\n\nGot:\n'+_inspect(path));}var node=path.node;if(node.hasBeenTypeChecked){return true;}if(node.leadingComments&&node.leadingComments.length){var comment=node.leadingComments[node.leadingComments.length-1];if(PRAGMA_IGNORE_STATEMENT.test(comment.value)){path.skip();return true;}}return false;} /**
   * A function that returns its first argument, useful when filtering.
   */function identity(input){return input;}function getExpression(node){function _ref100(_id115){if(!Node(_id115)){throw new TypeError('Function "getExpression" return value violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(_id115));}return _id115;}if(!Node(node)){throw new TypeError('Value of argument "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}return _ref100(t.isExpressionStatement(node)?node.expression:node);}function expression(input){function _ref101(_id116){if(!(typeof _id116==='function')){throw new TypeError('Function "expression" return value violates contract.\n\nExpected:\nFunction\n\nGot:\n'+_inspect(_id116));}return _id116;}if(!(typeof input==='string')){throw new TypeError('Value of argument "input" violates contract.\n\nExpected:\nstring\n\nGot:\n'+_inspect(input));}var fn=template(input);if(!(typeof fn==='function')){throw new TypeError('Value of variable "fn" violates contract.\n\nExpected:\nFunction\n\nGot:\n'+_inspect(fn));}return _ref101(function(){var node=fn.apply(undefined,arguments);if(!Node(node)){throw new TypeError('Value of variable "node" violates contract.\n\nExpected:\nNode\n\nGot:\n'+_inspect(node));}return getExpression(node);});}};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else {return Array.from(arr);}}var Node=function(){function Node(input){return input!=null&&typeof input.type==='string';};Object.defineProperty(Node,Symbol.hasInstance,{value:function value(input){return Node(input);}});return Node;}();var Literal=function(){function Literal(input){return input!=null&&(input.type==='StringLiteral'||input.type==='BooleanLiteral'||input.type==='NumericLiteral'||input.type==='NullLiteral'||input.type==='RegExpLiteral');};Object.defineProperty(Literal,Symbol.hasInstance,{value:function value(input){return Literal(input);}});return Literal;}();var Identifier=function(){function Identifier(input){return input!=null&&typeof input.type==='string'&&typeof input.name==='string';};Object.defineProperty(Identifier,Symbol.hasInstance,{value:function value(input){return Identifier(input);}});return Identifier;}();var QualifiedTypeIdentifier=function(){function QualifiedTypeIdentifier(input){return input!=null&&Identifier(input.id)&&(Identifier(input.qualification)||QualifiedTypeIdentifier(input.qualification));};Object.defineProperty(QualifiedTypeIdentifier,Symbol.hasInstance,{value:function value(input){return QualifiedTypeIdentifier(input);}});return QualifiedTypeIdentifier;}();var TypeAnnotation=function(){function TypeAnnotation(input){return input!=null&&typeof input.type==='string';};Object.defineProperty(TypeAnnotation,Symbol.hasInstance,{value:function value(input){return TypeAnnotation(input);}});return TypeAnnotation;}();var VisitorContext=function(){function VisitorContext(input){return input!=null&&Identifier(input.inspect);};Object.defineProperty(VisitorContext,Symbol.hasInstance,{value:function value(input){return VisitorContext(input);}});return VisitorContext;}();var StringLiteralTypeAnnotation=function(){function StringLiteralTypeAnnotation(input){return input!=null&&input.type==='StringLiteralTypeAnnotation'&&TypeAnnotation(input);};Object.defineProperty(StringLiteralTypeAnnotation,Symbol.hasInstance,{value:function value(input){return StringLiteralTypeAnnotation(input);}});return StringLiteralTypeAnnotation;}();var NumericLiteralTypeAnnotation=function(){function NumericLiteralTypeAnnotation(input){return input!=null&&input.type==='NumericLiteralTypeAnnotation'&&TypeAnnotation(input);};Object.defineProperty(NumericLiteralTypeAnnotation,Symbol.hasInstance,{value:function value(input){return NumericLiteralTypeAnnotation(input);}});return NumericLiteralTypeAnnotation;}();var BooleanLiteralTypeAnnotation=function(){function BooleanLiteralTypeAnnotation(input){return input!=null&&input.type==='BooleanLiteralTypeAnnotation'&&TypeAnnotation(input);};Object.defineProperty(BooleanLiteralTypeAnnotation,Symbol.hasInstance,{value:function value(input){return BooleanLiteralTypeAnnotation(input);}});return BooleanLiteralTypeAnnotation;}();var Scope=function(){function Scope(input){return input!=null&&(typeof input==='undefined'?'undefined':_typeof(input))==='object';};Object.defineProperty(Scope,Symbol.hasInstance,{value:function value(input){return Scope(input);}});return Scope;}();var NodePath=function(){function NodePath(input){return input!=null&&typeof input.type==='string'&&Node(input.node)&&Scope(input.scope);};Object.defineProperty(NodePath,Symbol.hasInstance,{value:function value(input){return NodePath(input);}});return NodePath;}(); /**
 * # Typecheck Transformer
 */function _inspect(input,depth){var maxDepth=4;var maxKeys=15;if(depth===undefined){depth=0;}depth+=1;if(input===null){return 'null';}else if(input===undefined){return 'void';}else if(typeof input==='string'||typeof input==='number'||typeof input==='boolean'){return typeof input==='undefined'?'undefined':_typeof(input);}else if(Array.isArray(input)){if(input.length>0){var _ret=function(){if(depth>maxDepth)return {v:'[...]'};var first=_inspect(input[0],depth);if(input.every(function(item){return _inspect(item,depth)===first;})){return {v:first.trim()+'[]'};}else {return {v:'['+input.slice(0,maxKeys).map(function(item){return _inspect(item,depth);}).join(', ')+(input.length>=maxKeys?', ...':'')+']'};}}();if((typeof _ret==='undefined'?'undefined':_typeof(_ret))==="object")return _ret.v;}else {return 'Array';}}else {var keys=Object.keys(input);if(!keys.length){if(input.constructor&&input.constructor.name&&input.constructor.name!=='Object'){return input.constructor.name;}else {return 'Object';}}if(depth>maxDepth)return '{...}';var indent='  '.repeat(depth-1);var entries=keys.slice(0,maxKeys).map(function(key){return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key)?key:JSON.stringify(key))+': '+_inspect(input[key],depth)+';';}).join('\n  '+indent);if(keys.length>=maxKeys){entries+='\n  '+indent+'...';}if(input.constructor&&input.constructor.name&&input.constructor.name!=='Object'){return input.constructor.name+' {\n  '+indent+entries+'\n'+indent+'}';}else {return '{\n  '+indent+entries+'\n'+indent+'}';}}}