'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally {try{if(!_n&&_i["return"])_i["return"]();}finally {if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else {throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}(); /**
 * # Typecheck Transformer
 */exports.default=function(_ref){var t=_ref.types;var template=_ref.template; /**
   * Binary Operators that can only produce boolean results.
   */var BOOLEAN_BINARY_OPERATORS=['==','===','>=','<=','>','<','instanceof'];var checks=createChecks();var staticChecks=createStaticChecks();var checkIsArray=expression('Array.isArray(input)');var checkIsMap=expression('input instanceof Map');var checkIsSet=expression('input instanceof Set');var checkIsClass=expression('typeof input === \'function\' && input.prototype && input.prototype.constructor === input');var checkIsGenerator=expression('typeof input === \'function\' && input.generator');var checkIsIterable=expression('input && (typeof input[Symbol.iterator] === \'function\' || Array.isArray(input))');var checkIsObject=expression('input != null && typeof input === \'object\'');var checkNotNull=expression('input != null');var checkEquals=expression('input === expected');var declareTypeChecker=template('\n    const id = (function () {\n      function id (input) {\n        return check;\n      };\n      Object.defineProperty(id, Symbol.hasInstance, {\n        value: function (input) {\n          return id(input);\n        }\n      });\n      return id;\n    })();\n  ');var guard=template('\n    if (!check) {\n      throw new TypeError(message);\n    }\n  ');var thrower=template('\n    if (check) {\n      ret;\n    }\n    else {\n      throw new TypeError(message);\n    }\n  ');var guardInline=expression('\n    (id => {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    })(input)\n  ');var guardFn=expression('\n    function name (id) {\n      if (!check) {\n        throw new TypeError(message);\n      }\n      return id;\n    }\n  ');var readableName=expression('\n    inspect(input)\n  ');var checkMapKeys=expression('\n    input instanceof Map && Array.from(input.keys()).every(key => keyCheck)\n  ');var checkMapValues=expression('\n    input instanceof Map && Array.from(input.values()).every(value => valueCheck)\n  ');var checkMapEntries=expression('\n    input instanceof Map && Array.from(input).every(([key, value]) => keyCheck && valueCheck)\n  ');var checkSetEntries=expression('\n    input instanceof Set && Array.from(input).every(value => valueCheck)\n  ');var checkObjectIndexers=expression('\n    Object.keys(input).every(key => {\n      const value = input[key];\n      if (~fixedKeys.indexOf(key)) {\n        return true;\n      }\n      else {\n        return check;\n      }\n    });\n  ');var checkObjectIndexersNoFixed=expression('\n    Object.keys(input).every(key => {\n      const value = input[key];\n      return check;\n    });\n  ');var propType=expression('\n    (function(props, name, component) {\n      var prop = props[name];\n      if(!check) {\n        return new Error(\n          "Invalid prop `" + name + "` supplied to `" + component\n          + "`.\\n\\nExpected:\\n" + expected + "\\n\\nGot:\\n" + got + "\\n\\n"\n        );\n      }\n    })\n  ');var PRAGMA_IGNORE_STATEMENT=/typecheck:\s*ignore\s+statement/i;var PRAGMA_IGNORE_FILE=/typecheck:\s*ignore\s+file/i;function skipEnvironment(comments,opts){if(!opts.only){return false;}var envs=pragmaEnvironments(comments);return !opts.only.some(function(env){return envs[env];});}function pragmaEnvironments(comments){var pragma=/@typecheck:\s*(.+)/;var environments={};comments.forEach(function(comment){var m=comment.value.match(pragma);if(m){m[1].split(',').forEach(function(env){return environments[env.trim()]=true;});}});return environments;}var visitors={Statement:function Statement(path){maybeSkip(path);},TypeAlias:function TypeAlias(path){if(maybeSkip(path)){return;}path.replaceWith(createTypeAliasChecks(path));},InterfaceDeclaration:function InterfaceDeclaration(path){if(maybeSkip(path)){return;}path.replaceWith(createInterfaceChecks(path));},ExportNamedDeclaration:function ExportNamedDeclaration(path){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;if(node.declaration&&node.declaration.type==='TypeAlias'){path.replaceWith(t.exportNamedDeclaration(createTypeAliasChecks(path.get('declaration')),[],null));}},ImportDeclaration:function ImportDeclaration(path){if(maybeSkip(path)){return;}if(path.node.importKind!=='type'){return;}var _path$get$map$reduce=path.get('specifiers').map(function(specifier){var local=specifier.get('local');var tmpId=path.scope.generateUidIdentifierBasedOnNode(local.node);var replacement=t.importSpecifier(tmpId,specifier.node.imported);var id=t.identifier(local.node.name);id.isTypeChecker=true;var declarator=t.variableDeclarator(id,tmpId);declarator.isTypeChecker=true;return [declarator,replacement];}).reduce(function(_ref2,_ref3){var _ref5=_slicedToArray(_ref2,2);var declarators=_ref5[0];var specifiers=_ref5[1];var _ref4=_slicedToArray(_ref3,2);var declarator=_ref4[0];var specifier=_ref4[1];declarators.push(declarator);specifiers.push(specifier);return [declarators,specifiers];},[[],[]]);var _path$get$map$reduce2=_slicedToArray(_path$get$map$reduce,2);var declarators=_path$get$map$reduce2[0];var specifiers=_path$get$map$reduce2[1];var declaration=t.variableDeclaration('var',declarators);declaration.isTypeChecker=true;path.replaceWithMultiple([t.importDeclaration(specifiers,path.node.source),declaration]);},ArrowFunctionExpression:function ArrowFunctionExpression(path){ // Look for destructuring args with annotations.
var params=path.get('params');var _iteratorNormalCompletion=true;var _didIteratorError=false;var _iteratorError=undefined;try{for(var _iterator=params[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=true){var param=_step.value;if(param.isObjectPattern()&&param.node.typeAnnotation){var _path$get=path.get('body');var _scope=_path$get.scope;var _id=_scope.generateUidIdentifier('arg'+param.key);var pattern=param.node;param.replaceWith(_id);if(path.node.expression){var block=t.blockStatement([t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]),t.returnStatement(path.get('body').node)]);path.node.body=block;path.node.expression=false;}else {path.get('body.body')[0].insertBefore(t.variableDeclaration('var',[t.variableDeclarator(pattern,_id)]));}}}}catch(err){_didIteratorError=true;_iteratorError=err;}finally {try{if(!_iteratorNormalCompletion&&_iterator.return){_iterator.return();}}finally {if(_didIteratorError){throw _iteratorError;}}}},Function:{enter:function enter(path,context){var _node$body$body;if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var paramChecks=collectParamChecks(path,context);if(node.type==="ArrowFunctionExpression"&&node.expression){node.expression=false;node.body=t.blockStatement([t.returnStatement(node.body)]);}if(node.returnType){createFunctionReturnGuard(path,context);createFunctionYieldGuards(path,context);}(_node$body$body=node.body.body).unshift.apply(_node$body$body,_toConsumableArray(paramChecks));node.savedTypeAnnotation=node.returnType;node.returnCount=0;node.yieldCount=0;},exit:function exit(path){var node=path.node;var scope=path.scope;var isVoid=node.savedTypeAnnotation?maybeNullableAnnotation(node.savedTypeAnnotation):null;if(!node.returnCount&&isVoid===false){var annotation=node.savedTypeAnnotation;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(node.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}throw path.buildCodeFrameError(buildErrorMessage('Function '+(node.id?'"'+node.id.name+'" ':'')+'did not return a value.',annotation));}if(node.nextGuardCount){path.get('body').get('body')[0].insertBefore(node.nextGuard);}if(node.yieldGuardCount){path.get('body').get('body')[0].insertBefore(node.yieldGuard);}if(node.returnGuardCount){path.get('body').get('body')[0].insertBefore(node.returnGuard);}}},YieldExpression:function YieldExpression(path,context){var fn=path.getFunctionParent();if(!fn){return;}fn.node.yieldCount++;if(!isGeneratorAnnotation(fn.node.returnType)||maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var annotation=fn.node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];var ok=staticCheckAnnotation(path.get("argument"),yieldType);if(ok===true&&!nextType){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'yielded an invalid type.',yieldType,getAnnotation(path.get('argument'))));}fn.node.yieldGuardCount++;if(fn.node.yieldGuard){var _yielder=t.yieldExpression(t.callExpression(fn.node.yieldGuardName,[node.argument||t.identifier('undefined')]));_yielder.hasBeenTypeChecked=true;if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[_yielder]));}else {path.replaceWith(_yielder);}}else if(fn.node.nextGuard){fn.node.nextGuardCount++;path.replaceWith(t.callExpression(fn.node.nextGuardName,[yielder]));}},ReturnStatement:function ReturnStatement(path,context){var fn=path.getFunctionParent();if(!fn){return;}fn.node.returnCount++;if(maybeSkip(path)){return;}var node=path.node;var parent=path.parent;var scope=path.scope;var _fn$node=fn.node;var returnType=_fn$node.returnType;var returnGuardName=_fn$node.returnGuardName;if(!returnType||!returnGuardName){return;}if(!node.argument){if(maybeNullableAnnotation(returnType)===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'did not return a value.',returnType));}return;}var annotation=returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var ok=staticCheckAnnotation(path.get("argument"),annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Function '+(fn.node.id?'"'+fn.node.id.name+'" ':'')+'returned an invalid type.',annotation,getAnnotation(path.get('argument'))));}fn.node.returnGuardCount++;var returner=t.returnStatement(t.callExpression(fn.node.returnGuardName,[node.argument]));returner.hasBeenTypeChecked=true;path.replaceWith(returner);},VariableDeclaration:function VariableDeclaration(path,context){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var collected=[];var declarations=path.get("declarations");for(var i=0;i<node.declarations.length;i++){var declaration=node.declarations[i];var _id2=declaration.id;var init=declaration.init;if(!_id2.typeAnnotation||_id2.hasBeenTypeChecked){continue;}_id2.savedTypeAnnotation=_id2.typeAnnotation;_id2.hasBeenTypeChecked=true;var ok=staticCheckAnnotation(declarations[i],_id2.typeAnnotation);if(ok===true){continue;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+_id2.name+'".',_id2.typeAnnotation,getAnnotation(declarations[i])));}var check=checkAnnotation(_id2,_id2.typeAnnotation,scope);if(check){collected.push(guard({check:check,message:varTypeErrorMessage(_id2,context)}));}}if(collected.length>0){var _check=collected.reduce(function(check,branch){branch.alternate=check;return branch;});if(path.parent.type==='Program'||path.parent.type==='BlockStatement'){path.insertAfter(_check);}else if(path.parentPath.isForXStatement()||path.parentPath.isForStatement()||path.parentPath.isForInStatement()){var body=path.parentPath.get('body');if(body.type!=='BlockStatement'){var block=t.blockStatement([body.node]);body.replaceWith(block);body=path.parentPath.get('body');}var children=body.get('body');if(children.length===0){body.replaceWith(_check);}else {children[0].insertBefore(_check);}}else if(path.parent.type==='ExportNamedDeclaration'||path.parent.type==='ExportDefaultDeclaration'||path.parent.type==='ExportAllDeclaration'){path.parentPath.insertAfter(_check);}else {path.replaceWith(t.blockStatement([node,_check]));}}},AssignmentExpression:function AssignmentExpression(path,context){if(maybeSkip(path)){return;}var node=path.node;var scope=path.scope;var left=path.get('left');var annotation=void 0;if(node.hasBeenTypeChecked||node.left.hasBeenTypeChecked){return;}else if(left.isMemberExpression()){annotation=getAnnotation(left);}else if(t.isIdentifier(node.left)){var binding=scope.getBinding(node.left.name);if(!binding){return;}else if(binding.path.type!=='VariableDeclarator'){return;}annotation=left.getTypeAnnotation();if(annotation.type==='AnyTypeAnnotation'){var item=binding.path.get('id');annotation=item.node.savedTypeAnnotation||item.getTypeAnnotation();}}else {return;}node.hasBeenTypeChecked=true;node.left.hasBeenTypeChecked=true;var id=node.left;var right=path.get('right');if(annotation.type==='AnyTypeAnnotation'){return;}var ok=staticCheckAnnotation(right,annotation);if(ok===true){return;}else if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid assignment value for "'+humanReadableType(id)+'".',annotation,getAnnotation(right)));}var check=checkAnnotation(id,annotation,scope);if(!id.typeAnnotation){id.typeAnnotation=annotation;}id.hasBeenTypeChecked=true;if(check){var parent=path.getStatementParent();parent.insertAfter(guard({check:check,message:varTypeErrorMessage(id,context)}));}},TypeCastExpression:function TypeCastExpression(path){var node=path.node;var target=void 0;switch(node.expression.type){case 'Identifier':target=node.expression;break;case 'AssignmentExpression':target=node.expression.left;break;default: // unsupported.
return;}var id=path.scope.getBindingIdentifier(target.name);if(!id){return;}id.savedTypeAnnotation=path.getTypeAnnotation();},ForOfStatement:function ForOfStatement(path,context){if(maybeSkip(path)){return;}var left=path.get('left');var right=path.get('right');var rightAnnotation=getAnnotation(right);var leftAnnotation=left.isVariableDeclaration()?getAnnotation(left.get('declarations')[0].get('id')):getAnnotation(left);if(rightAnnotation.type!=='VoidTypeAnnotation'&&rightAnnotation.type!=='NullLiteralTypeAnnotation'){var ok=maybeIterableAnnotation(rightAnnotation);if(ok===false){throw path.buildCodeFrameError('Cannot iterate '+humanReadableType(rightAnnotation)+'.');}}var id=void 0;if(right.isIdentifier()){id=right.node;}else {id=path.scope.generateUidIdentifierBasedOnNode(right.node);path.scope.push({id:id});var replacement=t.expressionStatement(t.assignmentExpression('=',id,right.node));path.insertBefore(replacement);right.replaceWith(id);}path.insertBefore(guard({check:checks.iterable({input:id}),message:t.binaryExpression('+',t.stringLiteral('Expected '+humanReadableType(right.node)+' to be iterable, got '),readableName({inspect:context.inspect,input:id}))}));if(rightAnnotation.type!=='GenericTypeAnnotation'||rightAnnotation.id.name!=='Iterable'||!rightAnnotation.typeParameters||!rightAnnotation.typeParameters.params.length){return;}var annotation=rightAnnotation.typeParameters.params[0];if(compareAnnotations(annotation,leftAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid iterator type.',annotation,leftAnnotation));}},ClassDeclaration:function ClassDeclaration(path,context){ // Convert React props to propTypes
if(!path.node.superClass){return;}var props=void 0;var hasRenderMethod=false;var _iteratorNormalCompletion2=true;var _didIteratorError2=false;var _iteratorError2=undefined;try{for(var _iterator2=path.get('body.body')[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=true){var memberPath=_step2.value;var classMember=memberPath.node;if(t.isClassProperty(classMember)){if(classMember.key.name==='propTypes'&&classMember.static){return;}else if(classMember.key.name==='props'&&!classMember.static){props=memberPath;}}if(t.isClassMethod(classMember)&&classMember.key.name==='render'){hasRenderMethod=true;}}}catch(err){_didIteratorError2=true;_iteratorError2=err;}finally {try{if(!_iteratorNormalCompletion2&&_iterator2.return){_iterator2.return();}}finally {if(_didIteratorError2){throw _iteratorError2;}}}var type=void 0;if(path.node.superTypeParameters){if(path.node.superTypeParameters.params.length!==3){return;}type=path.node.superTypeParameters.params[1];}if(props){type=props.node.typeAnnotation.typeAnnotation;}if(!type||!hasRenderMethod){return;}if(t.isGenericTypeAnnotation(type)){var binding=path.scope.getBinding(type.id.name);type=getAnnotation(binding.path);}if(!t.isObjectTypeAnnotation(type)){return;} // Now we have a class that has a superclass, an instance method called 'render'
// and some property type annotations. We can be reasonably sure it's a React component.
var propTypes=t.objectExpression(type.properties.map(function(prop){return t.objectProperty(t.identifier(prop.key.name),generatePropType(prop.value,path.scope,context));}));if(path.node.decorators){var property=t.classProperty(t.identifier('propTypes'),propTypes);property.static=true;props.insertAfter(property);}else {var root=path.parentPath.isExportDeclaration()?path.parentPath:path;root.insertAfter(t.expressionStatement(t.assignmentExpression("=",t.memberExpression(path.node.id,t.identifier("propTypes")),propTypes)));}}}; /**
   * Collect all the type declarations in the given path and add references to them for retreival later.
   */function collectTypes(path){path.traverse({TypeAlias:function TypeAlias(path){path.scope.setData('typechecker:'+path.node.id.name,path.node);},ImportDeclaration:function ImportDeclaration(path){if(path.node.importKind!=='type'){return;}path.get('specifiers').forEach(function(specifier){var local=specifier.get('local');path.scope.setData('typechecker:'+local.node.id.name,specifier.node);});}});}return {visitor:{Program:function Program(path,_ref6){var opts=_ref6.opts;if(opts&&opts.disable&&opts.disable[process.env.NODE_ENV]){return;}var checkFile=false;var _iteratorNormalCompletion3=true;var _didIteratorError3=false;var _iteratorError3=undefined;try{for(var _iterator3=path.get('body')[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=true){var _child=_step3.value;if(mustCheckFile(_child,opts)){checkFile=true;break;}}}catch(err){_didIteratorError3=true;_iteratorError3=err;}finally {try{if(!_iteratorNormalCompletion3&&_iterator3.return){_iterator3.return();}}finally {if(_didIteratorError3){throw _iteratorError3;}}}if(!checkFile){var _iteratorNormalCompletion4=true;var _didIteratorError4=false;var _iteratorError4=undefined;try{for(var _iterator4=path.get('body')[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=true){var child=_step4.value;if(maybeSkipFile(child,opts)){return;}}}catch(err){_didIteratorError4=true;_iteratorError4=err;}finally {try{if(!_iteratorNormalCompletion4&&_iterator4.return){_iterator4.return();}}finally {if(_didIteratorError4){throw _iteratorError4;}}}}collectTypes(path);var inspect=path.scope.generateUidIdentifier('inspect');var requiresHelpers={inspect:false};var context={get inspect(){requiresHelpers.inspect=true;return inspect;}};path.traverse(visitors,context);if(requiresHelpers.inspect){var body=path.get('body');body[body.length-1].insertAfter(template('\n            function id (input, depth) {\n              const maxDepth = 4;\n              const maxKeys = 15;\n              if (depth === undefined) {\n                depth = 0;\n              }\n              depth += 1;\n              if (input === null) {\n                return \'null\';\n              }\n              else if (input === undefined) {\n                return \'void\';\n              }\n              else if (typeof input === \'string\' || typeof input === \'number\' || typeof input === \'boolean\') {\n                return typeof input;\n              }\n              else if (Array.isArray(input)) {\n                if (input.length > 0) {\n                  if (depth > maxDepth) return \'[...]\';\n                  const first = id(input[0], depth);\n                  if (input.every(item => id(item, depth) === first)) {\n                    return first.trim() + \'[]\';\n                  }\n                  else {\n                    return \'[\' + input.slice(0, maxKeys).map(item => id(item, depth)).join(\', \') + (input.length >= maxKeys ? \', ...\' : \'\') + \']\';\n                  }\n                }\n                else {\n                  return \'Array\';\n                }\n              }\n              else {\n                const keys = Object.keys(input);\n                if (!keys.length) {\n                  if (input.constructor && input.constructor.name && input.constructor.name !== \'Object\') {\n                    return input.constructor.name;\n                  }\n                  else {\n                    return \'Object\';\n                  }\n                }\n                if (depth > maxDepth) return \'{...}\';\n                const indent = \'  \'.repeat(depth - 1);\n                let entries = keys.slice(0, maxKeys).map(key => {\n                  return (/^([A-Z_$][A-Z0-9_$]*)$/i.test(key) ? key : JSON.stringify(key)) + \': \' + id(input[key], depth) + \';\';\n                }).join(\'\\n  \' + indent);\n                if (keys.length >= maxKeys) {\n                  entries += \'\\n  \' + indent + \'...\';\n                }\n                if (input.constructor && input.constructor.name && input.constructor.name !== \'Object\') {\n                  return input.constructor.name + \' {\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n                else {\n                  return \'{\\n  \' + indent + entries + \'\\n\' + indent + \'}\';\n                }\n              }\n            }\n          ')({id:inspect}));}}}}; /**
   * Create a function which can verify the return type for a function.
   */function createFunctionReturnGuard(path,context){var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(isGeneratorAnnotation(annotation)){annotation=annotation.typeParameters&&annotation.typeParameters.params.length>1?annotation.typeParameters.params[1]:t.anyTypeAnnotation();}else if(node.async&&annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Promise'){annotation=annotation.typeParameters&&annotation.typeParameters[0]||t.anyTypeAnnotation();}var name=scope.generateUidIdentifierBasedOnNode(node);var id=scope.generateUidIdentifier('id');var check=checkAnnotation(id,annotation,scope);if(check){node.returnGuard=guardFn({id:id,name:name,check:check,message:returnTypeErrorMessage(path,path.node,id,context)});node.returnGuard.hasBeenTypeChecked=true;node.returnGuardName=name;node.returnGuardCount=0;}}function createFunctionYieldGuards(path,context){var node=path.node;var scope=path.scope;var annotation=node.returnType;if(annotation.type==='NullableTypeAnnotation'||annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!annotation.typeParameters||annotation.typeParameters.params.length===0){return;}if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(!isGeneratorAnnotation(annotation)){return;}var yieldType=annotation.typeParameters.params[0];var nextType=annotation.typeParameters.params[2];if(yieldType){var _name=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Yield');var _id3=scope.generateUidIdentifier('id');var check=checkAnnotation(_id3,yieldType,scope);if(check){node.yieldGuard=guardFn({id:_id3,name:_name,check:check,message:yieldTypeErrorMessage(node,yieldType,_id3,context)});node.yieldGuardName=_name;node.yieldGuardCount=0;}}if(nextType){var _name2=scope.generateUidIdentifier('check'+(node.id?node.id.name.slice(0,1).toUpperCase()+node.id.name.slice(1):'')+'Next');var _id4=scope.generateUidIdentifier('id');var _check2=checkAnnotation(_id4,nextType,scope);if(_check2){node.nextGuard=guardFn({id:_id4,name:_name2,check:_check2,message:yieldNextTypeErrorMessage(node,nextType,_id4,context)});node.nextGuardName=_name2;node.nextGuardCount=0;}}}function isThisMemberExpression(path){var node=path.node;if(node.type==='ThisExpression'){return true;}else if(node.type==='MemberExpression'){return isThisMemberExpression(path.get('object'));}else {return false;}}function isGeneratorAnnotation(annotation){if(!annotation){return false;}if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation.type==='GenericTypeAnnotation'&&annotation.id.name==='Generator';}function buildErrorMessage(message,expected,got){if(got){return message+'\n\nExpected:\n'+humanReadableType(expected)+'\n\nGot:\n'+humanReadableType(got);}else {return message+'\n\nExpected:\n'+humanReadableType(expected);}}function createChecks(){return {number:expression('typeof input === \'number\''),numericLiteral:checkNumericLiteral,boolean:expression('typeof input === \'boolean\''),booleanLiteral:checkBooleanLiteral,class:checkClass,function:expression('typeof input === \'function\''),string:expression('typeof input === \'string\''),stringLiteral:checkStringLiteral,symbol:expression('typeof input === \'symbol\''),undefined:expression('input === undefined'),null:expression('input === null'),void:expression('input == null'),instanceof:expression('input instanceof type'),type:expression('type(input)'),mixed:function mixed(){return null;},any:function any(){return null;},union:checkUnion,intersection:checkIntersection,array:checkArray,map:checkMap,set:checkSet,generator:checkGenerator,iterable:checkIterable,tuple:checkTuple,object:checkObject,nullable:checkNullable,typeof:checkTypeof,int8:expression('typeof input === \'number\' && !isNaN(input) && input >= -128 && input <= 127 && input === Math.floor(input)'),uint8:expression('typeof input === \'number\' && !isNaN(input) && input >= 0 && input <= 255 && input === Math.floor(input)'),int16:expression('typeof input === \'number\' && !isNaN(input) && input >= -32768 && input <= 32767 && input === Math.floor(input)'),uint16:expression('typeof input === \'number\' && !isNaN(input) && input >= 0 && input <= 65535 && input === Math.floor(input)'),int32:expression('typeof input === \'number\' && !isNaN(input) && input >= -2147483648 && input <= 2147483647 && input === Math.floor(input)'),uint32:expression('typeof input === \'number\' && !isNaN(input) && input >= 0 && input <= 4294967295 && input === Math.floor(input)'),float32:expression('typeof input === \'number\' && !isNaN(input) && input >= -3.40282347e+38 && input <= 3.40282347e+38'),float64:expression('typeof input === \'number\' && !isNaN(input)'),double:expression('typeof input === \'number\' && !isNaN(input)')};}function createStaticChecks(){return {symbol:function symbol(path){return maybeSymbolAnnotation(getAnnotation(path));},instanceof:function _instanceof(_ref7){var path=_ref7.path;var annotation=_ref7.annotation;var type=createTypeExpression(annotation.id);var node=path.node;var scope=path.scope;if(type.name==='Object'&&node.type==='ObjectExpression'&&!scope.getBinding('Object')){return true;}else if(type.name==='Map'&&!scope.getBinding('Map')){return null;}else if(type.name==='Set'&&!scope.getBinding('Set')){return null;}else if(type.name==='Class'&&!scope.hasBinding('Class')){return null;}else if(type.name==='int8'&&!scope.hasBinding('int8')){return null;}else if(type.name==='uint8'&&!scope.hasBinding('uint8')){return null;}else if(type.name==='int16'&&!scope.hasBinding('int16')){return null;}else if(type.name==='uint16'&&!scope.hasBinding('uint16')){return null;}else if(type.name==='int32'&&!scope.hasBinding('int32')){return null;}else if(type.name==='uint32'&&!scope.hasBinding('uint32')){return null;}else if(type.name==='float32'&&!scope.hasBinding('float32')){return null;}else if(type.name==='float64'&&!scope.hasBinding('float64')){return null;}else if(type.name==='double'&&!scope.hasBinding('double')){return null;}return maybeInstanceOfAnnotation(getAnnotation(path),type,annotation.typeParameters?annotation.typeParameters.params:[]);},type:function(_type){function type(_x){return _type.apply(this,arguments);}type.toString=function(){return _type.toString();};return type;}(function(_ref8){var path=_ref8.path;var type=_ref8.type;return null;})};}function compareAnnotations(a,b){if(a.type==='TypeAnnotation'){a=a.typeAnnotation;}if(b.type==='TypeAnnotation'){b=b.typeAnnotation;}switch(a.type){case 'StringTypeAnnotation':return maybeStringAnnotation(b);case 'StringLiteral':case 'StringLiteralTypeAnnotation':return compareStringLiteralAnnotations(a,b);case 'NumberTypeAnnotation':return maybeNumberAnnotation(b);case 'NumericLiteral':case 'NumericLiteralTypeAnnotation':return compareNumericLiteralAnnotations(a,b);case 'BooleanTypeAnnotation':return maybeBooleanAnnotation(b);case 'BooleanLiteral':case 'BooleanLiteralTypeAnnotation':return compareBooleanLiteralAnnotations(a,b);case 'FunctionTypeAnnotation':return maybeFunctionAnnotation(b);case 'AnyTypeAnnotation':return null;case 'MixedTypeAnnotation':return null;case 'ObjectTypeAnnotation':return compareObjectAnnotation(a,b);case 'ArrayTypeAnnotation':return compareArrayAnnotation(a,b);case 'GenericTypeAnnotation':return compareGenericAnnotation(a,b);case 'TupleTypeAnnotation':return compareTupleAnnotation(a,b);case 'UnionTypeAnnotation':return compareUnionAnnotation(a,b);case 'IntersectionTypeAnnotation':return compareIntersectionAnnotation(a,b);case 'NullableTypeAnnotation':return compareNullableAnnotation(a,b);default:return null;}}function compareStringLiteralAnnotations(a,b){if(b.type==='StringLiteralTypeAnnotation'||b.type==='StringLiteral'){return a.value===b.value;}else {return maybeStringAnnotation(b)===false?false:null;}}function compareBooleanLiteralAnnotations(a,b){if(b.type==='BooleanLiteralTypeAnnotation'||b.type==='BooleanLiteral'){return a.value===b.value;}else {return maybeBooleanAnnotation(b)===false?false:null;}}function compareNumericLiteralAnnotations(a,b){if(b.type==='NumericLiteralTypeAnnotation'||b.type==='NumericLiteral'){return a.value===b.value;}else {return maybeNumberAnnotation(b)===false?false:null;}}function unionComparer(a,b,comparator){if(!a.types||a.types.length===0){return null;}var falseCount=0;var trueCount=0;if(!a.types){return null;}var _iteratorNormalCompletion5=true;var _didIteratorError5=false;var _iteratorError5=undefined;try{for(var _iterator5=a.types[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=true){var _type2=_step5.value;var result=comparator(_type2,b);if(result===true){if(b.type!=='UnionTypeAnnotation'){return true;}trueCount++;}else if(result===false){if(b.type==='UnionTypeAnnotation'){return false;}falseCount++;}}}catch(err){_didIteratorError5=true;_iteratorError5=err;}finally {try{if(!_iteratorNormalCompletion5&&_iterator5.return){_iterator5.return();}}finally {if(_didIteratorError5){throw _iteratorError5;}}}if(falseCount===a.types.length){return false;}else if(trueCount===a.types.length){return true;}else {return null;}}function intersectionComparer(a,b,comparator){var falseCount=0;var trueCount=0;if(!a.types){return null;}var _iteratorNormalCompletion6=true;var _didIteratorError6=false;var _iteratorError6=undefined;try{for(var _iterator6=a.types[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=true){var _type3=_step6.value;var result=comparator(_type3,b);if(result===true){trueCount++;}else if(result===false){return false;}}}catch(err){_didIteratorError6=true;_iteratorError6=err;}finally {try{if(!_iteratorNormalCompletion6&&_iterator6.return){_iterator6.return();}}finally {if(_didIteratorError6){throw _iteratorError6;}}}if(trueCount===a.types.length){return true;}else {return null;}}function compareObjectAnnotation(a,b){switch(b.type){case 'ObjectTypeAnnotation':break;case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareObjectAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareObjectAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareObjectAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;} // We're comparing two object annotations.
var allTrue=true;var _iteratorNormalCompletion7=true;var _didIteratorError7=false;var _iteratorError7=undefined;try{for(var _iterator7=a.properties[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=true){var aprop=_step7.value;var found=false;var _iteratorNormalCompletion8=true;var _didIteratorError8=false;var _iteratorError8=undefined;try{for(var _iterator8=b.properties[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=true){var bprop=_step8.value;if(bprop.key.name===aprop.key.name){var result=compareAnnotations(aprop.value,bprop.value);if(result===false&&!(aprop.optional&&(bprop.optional||maybeNullableAnnotation(bprop.value)===true))){return false;}else {found=result;}break;}}}catch(err){_didIteratorError8=true;_iteratorError8=err;}finally {try{if(!_iteratorNormalCompletion8&&_iterator8.return){_iterator8.return();}}finally {if(_didIteratorError8){throw _iteratorError8;}}}if(found===false&&!aprop.optional){return false;}allTrue=allTrue&&found===true;}}catch(err){_didIteratorError7=true;_iteratorError7=err;}finally {try{if(!_iteratorNormalCompletion7&&_iterator7.return){_iterator7.return();}}finally {if(_didIteratorError7){throw _iteratorError7;}}}return allTrue?true:null;}function compareArrayAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareArrayAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareArrayAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareArrayAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;}}function compareGenericAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareGenericAnnotation(a,b.typeAnnotation);case 'GenericTypeAnnotation':if(b.id.name===a.id.name){return true;}else {return null;}case 'UnionTypeAnnotation':return unionComparer(a,b,compareGenericAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareGenericAnnotation);default:return null;}}function compareTupleAnnotation(a,b){if(b.type==='TupleTypeAnnotation'){if(b.types.length===0){return null;}else if(b.types.length<a.types.length){return false;}return a.types.every(function(type,index){return compareAnnotations(type,b.types[index]);});}switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return compareTupleAnnotation(a,b.typeAnnotation);case 'UnionTypeAnnotation':return unionComparer(a,b,compareTupleAnnotation);case 'IntersectionTypeAnnotation':return intersectionComparer(a,b,compareTupleAnnotation);case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'FunctionTypeAnnotation':return false;default:return null;}}function compareUnionAnnotation(a,b){switch(b.type){case 'NullableTypeAnnotation':return compareUnionAnnotation(a,b.typeAnnotation);case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':return null;default:return unionComparer(a,b,compareAnnotations);}}function compareNullableAnnotation(a,b){switch(b.type){case 'TypeAnnotation':case 'FunctionTypeParam':return compareNullableAnnotation(a,b.typeAnnotation);case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return null;}if(compareAnnotations(a.typeAnnotation,b)===true){return true;}else {return null;}}function arrayExpressionToTupleAnnotation(path){var elements=path.get('elements');return t.tupleTypeAnnotation(elements.map(function(element){return getAnnotation(element);}));}function checkNullable(_ref9){var input=_ref9.input;var type=_ref9.type;var scope=_ref9.scope;var check=checkAnnotation(input,type,scope);if(!check){return;}return t.logicalExpression("||",checks.void({input:input}),check);}function checkTypeof(_ref10){var input=_ref10.input;var annotation=_ref10.annotation;var scope=_ref10.scope;switch(annotation.type){case 'GenericTypeAnnotation':var id=annotation.id;var path=Object.assign({},input,{type:id.type,node:id,scope:scope});return checkAnnotation(input,getAnnotation(path),scope);default:return checkAnnotation(input,annotation,scope);}}function checkStringLiteral(_ref11){var input=_ref11.input;var annotation=_ref11.annotation;return checkEquals({input:input,expected:t.stringLiteral(annotation.value)});}function checkNumericLiteral(_ref12){var input=_ref12.input;var annotation=_ref12.annotation;return checkEquals({input:input,expected:t.numericLiteral(annotation.value)});}function checkBooleanLiteral(_ref13){var input=_ref13.input;var annotation=_ref13.annotation;return checkEquals({input:input,expected:t.booleanLiteral(annotation.value)});}function checkUnion(_ref14){var input=_ref14.input;var types=_ref14.types;var scope=_ref14.scope;var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression("||",last,check);},null);}function checkIntersection(_ref15){var input=_ref15.input;var types=_ref15.types;var scope=_ref15.scope;var checks=types.map(function(type){return checkAnnotation(input,type,scope);}).filter(identity);return checks.reduce(function(last,check,index){if(last==null){return check;}return t.logicalExpression("&&",last,check);},null);}function checkMap(_ref16){var input=_ref16.input;var types=_ref16.types;var scope=_ref16.scope;var _types=_slicedToArray(types,2);var keyType=_types[0];var valueType=_types[1];var key=t.identifier('key');var value=t.identifier('value');var keyCheck=keyType?checkAnnotation(key,keyType,scope):null;var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!keyCheck){if(!valueCheck){return checkIsMap({input:input});}else {return checkMapValues({input:input,value:value,valueCheck:valueCheck});}}else {if(!valueCheck){return checkMapKeys({input:input,key:key,keyCheck:keyCheck});}else {return checkMapEntries({input:input,key:key,value:value,keyCheck:keyCheck,valueCheck:valueCheck});}}}function checkSet(_ref17){var input=_ref17.input;var types=_ref17.types;var scope=_ref17.scope;var _types2=_slicedToArray(types,1);var valueType=_types2[0];var value=t.identifier('value');var valueCheck=valueType?checkAnnotation(value,valueType,scope):null;if(!valueCheck){return checkIsSet({input:input});}else {return checkSetEntries({input:input,value:value,valueCheck:valueCheck});}}function checkGenerator(_ref18){var input=_ref18.input;var types=_ref18.types;var scope=_ref18.scope;return checkIsGenerator({input:input});}function checkIterable(_ref19){var input=_ref19.input;var types=_ref19.types;var scope=_ref19.scope;return checkIsIterable({input:input});}function checkClass(_ref20){var input=_ref20.input;var types=_ref20.types;var scope=_ref20.scope;return checkIsClass({input:input});}function checkArray(_ref21){var input=_ref21.input;var types=_ref21.types;var scope=_ref21.scope;if(!types||types.length===0){return checkIsArray({input:input});}else if(types.length===1){var item=t.identifier('item');var _type4=types[0];var check=checkAnnotation(item,_type4,scope);if(!check){return checkIsArray({input:input});}return t.logicalExpression('&&',checkIsArray({input:input}),t.callExpression(t.memberExpression(input,t.identifier('every')),[t.functionExpression(null,[item],t.blockStatement([t.returnStatement(check)]))]));}else { // This is a tuple
var _checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return _checks.reduce(function(last,check,index){return t.logicalExpression("&&",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength));}}function checkTuple(_ref22){var input=_ref22.input;var types=_ref22.types;var scope=_ref22.scope;if(types.length===0){return checkIsArray({input:input});} // This is a tuple
var checks=types.map(function(type,index){return checkAnnotation(t.memberExpression(input,t.numericLiteral(index),true),type,scope);}).filter(identity);var checkLength=t.binaryExpression('>=',t.memberExpression(input,t.identifier('length')),t.numericLiteral(types.length));return checks.reduce(function(last,check,index){return t.logicalExpression("&&",last,check);},t.logicalExpression('&&',checkIsArray({input:input}),checkLength));}function checkObject(_ref23){var input=_ref23.input;var properties=_ref23.properties;var indexers=_ref23.indexers;var scope=_ref23.scope;if(input.type==='ObjectPattern'){return checkObjectPattern({input:input,properties:properties,scope:scope});}var propNames=[];var check=properties.length===0?checkIsObject({input:input}):properties.reduce(function(expr,prop,index){var target=prop.key.type==='Identifier'?t.memberExpression(input,prop.key):t.memberExpression(input,prop.key,true);propNames.push(prop.key.type==='Identifier'?t.stringLiteral(prop.key.name):prop.key);var check=checkAnnotation(target,prop.value,scope);if(check){if(prop.optional){check=t.logicalExpression('||',checks.undefined({input:target}),check);}return t.logicalExpression("&&",expr,check);}else {return expr;}},checkNotNull({input:input}));if(indexers.length){return indexers.reduceRight(function(expr,indexer){if(indexer.value.type==='AnyTypeAnnotation'){return expr;}var value=scope.generateUidIdentifier(indexer.id.name);var check=checkAnnotation(value,indexer.value,scope);var fixedKeys=t.arrayExpression(propNames);if(check){if(propNames.length){return t.logicalExpression('&&',expr,checkObjectIndexers({input:input,value:value,check:check,fixedKeys:fixedKeys}));}else {return t.logicalExpression('&&',expr,checkObjectIndexersNoFixed({input:input,value:value,check:check,fixedKeys:fixedKeys}));}}else {return expr;}},check);}return check;}function checkObjectPattern(_ref24){var input=_ref24.input;var properties=_ref24.properties;var scope=_ref24.scope;var propNames=properties.reduce(function(names,prop){names[prop.key.name]=prop;return names;},{});var propChecks={};var _iteratorNormalCompletion9=true;var _didIteratorError9=false;var _iteratorError9=undefined;try{for(var _iterator9=input.properties[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=true){var item=_step9.value;var key=item.key;var _id5=item.value;var prop=propNames[key.name];if(!prop){continue;}var check=checkAnnotation(_id5,prop.value,scope);if(check){propChecks[key.name]=check;}}}catch(err){_didIteratorError9=true;_iteratorError9=err;}finally {try{if(!_iteratorNormalCompletion9&&_iterator9.return){_iterator9.return();}}finally {if(_didIteratorError9){throw _iteratorError9;}}}return Object.keys(propChecks).reduce(function(last,name){var check=propChecks[name];if(last===null){return check;}else {return t.logicalExpression('&&',last,check);}},null);}function createTypeAliasChecks(path){var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.right;var input=t.identifier('input');var check=checkAnnotation(input,annotation,scope)||t.booleanLiteral(true);var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;declaration.savedTypeAnnotation=annotation;declaration.declarations[0].savedTypeAnnotation=annotation;return declaration;}function createInterfaceChecks(path){var node=path.node;var scope=path.scope;var id=node.id;var annotation=node.body;var input=t.identifier('input');var check=node.extends.reduce(function(check,extender){return t.logicalExpression('&&',check,checkAnnotation(input,t.genericTypeAnnotation(extender.id),path.scope));return check;},checkAnnotation(input,annotation,scope)||t.booleanLiteral(true));var declaration=declareTypeChecker({id:id,check:check});declaration.isTypeChecker=true;return declaration;}function checkAnnotation(input,annotation,scope){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return checkAnnotation(input,annotation.typeAnnotation,scope);case 'TypeofTypeAnnotation':return checks.typeof({input:input,annotation:annotation.argument,scope:scope});case 'GenericTypeAnnotation':if(annotation.id.name==='Array'){return checks.array({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Generator'&&!scope.hasBinding('Generator')){return checks.generator({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Iterable'&&!scope.hasBinding('Iterable')){return checks.iterable({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Map'&&!scope.getBinding('Map')){return checks.map({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Set'&&!scope.getBinding('Set')){return checks.set({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='Function'){return checks.function({input:input});}else if(annotation.id.name==='Class'&&!scope.hasBinding('Class')){return checks.class({input:input,types:annotation.typeParameters?annotation.typeParameters.params:[],scope:scope});}else if(annotation.id.name==='int8'&&!scope.hasBinding('int8')){return checks.int8({input:input});}else if(annotation.id.name==='uint8'&&!scope.hasBinding('uint8')){return checks.uint8({input:input});}else if(annotation.id.name==='int16'&&!scope.hasBinding('int16')){return checks.int16({input:input});}else if(annotation.id.name==='uint16'&&!scope.hasBinding('uint16')){return checks.uint16({input:input});}else if(annotation.id.name==='int32'&&!scope.hasBinding('int32')){return checks.int32({input:input});}else if(annotation.id.name==='uint32'&&!scope.hasBinding('uint32')){return checks.uint32({input:input});}else if(annotation.id.name==='float32'&&!scope.hasBinding('float32')){return checks.float32({input:input});}else if(annotation.id.name==='float64'&&!scope.hasBinding('float64')){return checks.float64({input:input});}else if(annotation.id.name==='double'&&!scope.hasBinding('double')){return checks.double({input:input});}else if(annotation.id.name==='Symbol'&&!scope.getBinding('Symbol')){return checks.symbol({input:input});}else if(isTypeChecker(annotation.id,scope)){return checks.type({input:input,type:annotation.id});}else if(isPolymorphicType(annotation.id,scope)){return;}else {return checks.instanceof({input:input,type:createTypeExpression(annotation.id)});}case 'TupleTypeAnnotation':return checks.tuple({input:input,types:annotation.types,scope:scope});case 'NumberTypeAnnotation':return checks.number({input:input});case 'NumericLiteralTypeAnnotation':return checks.numericLiteral({input:input,annotation:annotation});case 'BooleanTypeAnnotation':return checks.boolean({input:input});case 'BooleanLiteralTypeAnnotation':return checks.booleanLiteral({input:input,annotation:annotation});case 'StringTypeAnnotation':return checks.string({input:input});case 'StringLiteralTypeAnnotation':return checks.stringLiteral({input:input,annotation:annotation});case 'UnionTypeAnnotation':return checks.union({input:input,types:annotation.types,scope:scope});case 'IntersectionTypeAnnotation':return checks.intersection({input:input,types:annotation.types,scope:scope});case 'ObjectTypeAnnotation':return checks.object({input:input,properties:annotation.properties||[],indexers:annotation.indexers,scope:scope});case 'ArrayTypeAnnotation':return checks.array({input:input,types:[annotation.elementType||t.anyTypeAnnotation()],scope:scope});case 'FunctionTypeAnnotation':return checks.function({input:input,params:annotation.params,returnType:annotation.returnType});case 'MixedTypeAnnotation':return checks.mixed({input:input});case 'AnyTypeAnnotation':case 'ExistentialTypeParam':return checks.any({input:input});case 'NullableTypeAnnotation':return checks.nullable({input:input,type:annotation.typeAnnotation,scope:scope});case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return checks.void({input:input});}}function staticCheckAnnotation(path,annotation){var other=getAnnotation(path);switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return staticCheckAnnotation(path,annotation.typeAnnotation);case 'GenericTypeAnnotation':if(isTypeChecker(annotation.id,path.scope)){return staticChecks.type({path:path,type:annotation.id});}else if(isPolymorphicType(annotation.id,path.scope)){return;}else if(annotation.id.name==='Symbol'){return staticChecks.symbol(path);}else {return staticChecks.instanceof({path:path,annotation:annotation});}}return compareAnnotations(annotation,other);} /**
   * Get the type annotation for a given node.
   */function getAnnotation(path){var annotation=void 0;try{annotation=getAnnotationShallow(path);}catch(e){if(e instanceof SyntaxError){throw e;}if(process.env.TYPECHECK_DEBUG){console.error(e.stack);}}while(annotation&&annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}return annotation||t.anyTypeAnnotation();}function getAnnotationShallow(path){if(!path||!path.node){return t.voidTypeAnnotation();}var node=path.node;var scope=path.scope;if(node.type==='TypeAlias'){return node.right;}else if(node.type==='ClassProperty'&&node.typeAnnotation){return getClassPropertyAnnotation(path);}else if(node.type==='ClassMethod'&&node.returnType){return getClassMethodAnnotation(path);}else if(node.type==='ObjectProperty'&&node.typeAnnotation){return getObjectPropertyAnnotation(path);}else if(node.type==='SpreadProperty'&&node.typeAnnotation){return getSpreadPropertyAnnotation(path);}else if(node.type==='ObjectMethod'&&node.returnType){return getObjectMethodAnnotation(path);}else if(!node.typeAnnotation&&!node.savedTypeAnnotation&&!node.returnType){switch(path.type){case 'Identifier':var binding=scope.getBinding(node.name);if(!binding||!binding.identifier){return path.getTypeAnnotation();}var id=binding.identifier;if(binding.path.type==='ObjectPattern'){return getObjectPatternAnnotation(binding.path,node.name);}if(id.savedTypeAnnotation){return id.savedTypeAnnotation;}else if(id.returnType){return id.returnType;}else if(id.typeAnnotation){return id.typeAnnotation;}else if(isPolymorphicType(id,scope)){return t.anyTypeAnnotation();}return binding.constant?binding.path.getTypeAnnotation():path.getTypeAnnotation();case 'StringLiteral':case 'NumericLiteral':case 'BooleanLiteral':return createLiteralTypeAnnotation(path);case 'CallExpression':var callee=path.get('callee');if(callee.type==='Identifier'){if(callee.name==='Symbol'){return t.genericTypeAnnotation('Symbol');}var fn=getFunctionForIdentifier(callee);if(fn){return getAnnotation(fn);}}break;case 'ThisExpression':return getThisExpressionAnnotation(path);case 'AssignmentExpression':return getAssignmentExpressionAnnotation(path);case 'MemberExpression':return getMemberExpressionAnnotation(path);case 'ArrayExpression':return getArrayExpressionAnnotation(path);case 'ObjectExpression':return getObjectExpressionAnnotation(path);case 'BinaryExpression':return getBinaryExpressionAnnotation(path);case 'LogicalExpression':return getLogicalExpressionAnnotation(path);case 'ConditionalExpression':return getConditionalExpressionAnnotation(path);case 'ObjectMethod':return getObjectMethodAnnotation(path);case 'SpreadProperty':return getSpreadPropertyAnnotation(path);case 'ObjectProperty':return getObjectPropertyAnnotation(path);case 'ClassDeclaration':return getClassDeclarationAnnotation(path);case 'ClassMethod':return getClassMethodAnnotation(path);case 'ClassProperty':return getClassPropertyAnnotation(path);default:return path.getTypeAnnotation();}}return node.savedTypeAnnotation||node.returnType||node.typeAnnotation||path.getTypeAnnotation();}function createLiteralTypeAnnotation(path){var annotation=void 0;if(path.isStringLiteral()){annotation=t.stringLiteralTypeAnnotation();}else if(path.isNumericLiteral()){annotation=t.numericLiteralTypeAnnotation();}else if(path.isBooleanLiteral()){annotation=t.booleanLiteralTypeAnnotation();}else {return path.getTypeAnnotation();}annotation.value=path.node.value;return annotation;}function getObjectPatternAnnotation(path,name){var annotation=keyByName(getAnnotation(path),name);var found=void 0;if(!path.node.properties){return;}var _iteratorNormalCompletion10=true;var _didIteratorError10=false;var _iteratorError10=undefined;try{for(var _iterator10=path.get('properties')[Symbol.iterator](),_step10;!(_iteratorNormalCompletion10=(_step10=_iterator10.next()).done);_iteratorNormalCompletion10=true){var prop=_step10.value;if(prop.node.value&&prop.node.value.name===name){found=prop.get('key');break;}else if(prop.node.key.type==='Identifier'&&prop.node.key.name===name){found=prop.get('key');break;}}}catch(err){_didIteratorError10=true;_iteratorError10=err;}finally {try{if(!_iteratorNormalCompletion10&&_iterator10.return){_iterator10.return();}}finally {if(_didIteratorError10){throw _iteratorError10;}}}if(!annotation||!found){return;}if(found.type==='Identifier'){annotation.value.authoritative=false;return annotation.value;}}function keyByName(node,name){if(!node.properties){return;}var _iteratorNormalCompletion11=true;var _didIteratorError11=false;var _iteratorError11=undefined;try{for(var _iterator11=node.properties[Symbol.iterator](),_step11;!(_iteratorNormalCompletion11=(_step11=_iterator11.next()).done);_iteratorNormalCompletion11=true){var prop=_step11.value;if(prop.key&&prop.key.name===name){return prop;}}}catch(err){_didIteratorError11=true;_iteratorError11=err;}finally {try{if(!_iteratorNormalCompletion11&&_iterator11.return){_iterator11.return();}}finally {if(_didIteratorError11){throw _iteratorError11;}}}}function valueByName(node,name){if(!node.properties){return;}var _iteratorNormalCompletion12=true;var _didIteratorError12=false;var _iteratorError12=undefined;try{for(var _iterator12=node.properties[Symbol.iterator](),_step12;!(_iteratorNormalCompletion12=(_step12=_iterator12.next()).done);_iteratorNormalCompletion12=true){var prop=_step12.value;if(prop.value&&prop.value.name===name){return prop;}}}catch(err){_didIteratorError12=true;_iteratorError12=err;}finally {try{if(!_iteratorNormalCompletion12&&_iterator12.return){_iterator12.return();}}finally {if(_didIteratorError12){throw _iteratorError12;}}}}function getSpreadPropertyAnnotation(path){var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){annotation=getAnnotation(path.get('argument'));}return annotation;}function getObjectPropertyAnnotation(path){var node=path.node;var annotation=node.typeAnnotation||node.savedTypeAnnotation;if(!annotation){if(node.value){if(node.value.typeAnnotation||node.value.savedTypeAnnotation){annotation=node.value.typeAnnotation||node.value.savedTypeAnnotation;}else if(node.value.type==='BooleanLiteral'||node.value.type==='NumericLiteral'||node.value.type==='StringLiteral'){annotation=t[node.value.type](node.value.value);}else {annotation=t.anyTypeAnnotation();}}else {annotation=t.anyTypeAnnotation();}}return t.objectTypeProperty(node.key,annotation);}function getObjectMethodAnnotation(path){var node=path.node;return t.objectTypeProperty(t.identifier(node.key.name),t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}function getThisExpressionAnnotation(path){var parent=path.parentPath;loop: while(parent){switch(parent.type){case 'ClassDeclaration':return getAnnotation(parent);case 'ClassBody':return getAnnotation(parent.parentPath);case 'ClassMethod':case 'ClassProperty':return getAnnotation(parent.parentPath.parentPath);case 'ObjectProperty':return getAnnotation(parent.parentPath);case 'ObjectMethod':return getAnnotation(parent.parentPath);case 'FunctionExpression':if(parent.parentPath.type==='ObjectProperty'){return getAnnotation(parent.parentPath.parentPath);}break loop;case 'ArrowFunctionExpression':parent=parent.parentPath;continue;}if(parent.isFunction()){break;}parent=parent.parentPath;}return t.objectTypeAnnotation([]);}function getClassDeclarationAnnotation(path){var body=path.get('body').get('body').map(getAnnotation).filter(function(annotation){return annotation&&annotation.type!=='AnyTypeAnnotation';});return t.objectTypeAnnotation(body);}function getAssignmentExpressionAnnotation(path){if(path.node.operator==='='){return getAnnotation(path.get('right'));}}function getClassPropertyAnnotation(path){var node=path.node;if(node.computed){return;}var annotation=node.typeAnnotation||(node.value?node.value.savedTypeAnnotation||node.value.typeAnnotation:t.anyTypeAnnotation());return t.objectTypeProperty(node.key,annotation||t.anyTypeAnnotation());}function getClassMethodAnnotation(path){var node=path.node;if(node.computed){return;}if(node.kind==='get'){return t.objectTypeProperty(node.key,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation());}else if(node.kind==='set'){return t.objectTypeProperty(node.key,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation;}).shift()||t.anyTypeAnnotation());}else {return t.objectTypeProperty(node.key,t.functionTypeAnnotation(null,node.params.map(function(param){return param.savedTypeAnnotation||param.typeAnnotation||t.anyTypeAnnotation();}),null,node.savedTypeAnnotation||node.returnType||node.typeAnnotation||t.anyTypeAnnotation()));}}function getBinaryExpressionAnnotation(path){var node=path.node;if(isBooleanExpression(node)){return t.booleanTypeAnnotation();}else {return t.anyTypeAnnotation();}}function getLogicalExpressionAnnotation(path){var node=path.node;if(isBooleanExpression(node)){return t.booleanTypeAnnotation();}else {var left=path.get('left');var right=path.get('right');switch(node.operator){case '&&':case '||':var _ref25=[getAnnotation(left),getAnnotation(right)];left=_ref25[0];right=_ref25[1];if(t.isUnionTypeAnnotation(left)){if(t.isUnionTypeAnnotation(right)){return t.unionTypeAnnotation(left.types.concat(right.types));}else {return t.unionTypeAnnotation(left.types.concat(right));}}else {return t.unionTypeAnnotation([left,right]);}}return t.anyTypeAnnotation();}}function getConditionalExpressionAnnotation(path){var node=path.node;var consequent=getAnnotation(path.get('consequent'));var alternate=getAnnotation(path.get('alternate'));if(t.isUnionTypeAnnotation(consequent)){if(t.isUnionTypeAnnotation(alternate)){return t.unionTypeAnnotation(consequent.types.concat(alternate.types));}else {return t.unionTypeAnnotation(consequent.types.concat(alternate));}}else {return t.unionTypeAnnotation([consequent,alternate]);}}function getArrayExpressionAnnotation(path){return t.genericTypeAnnotation(t.identifier('Array'),t.typeParameterDeclaration(path.get('elements').map(getAnnotation)));}function getObjectExpressionAnnotation(path){var annotation=t.objectTypeAnnotation(path.get('properties').filter(function(prop){return !prop.node.computed;}).map(getAnnotation).reduce(function(properties,prop){if(t.isObjectTypeProperty(prop)){properties.push(prop);}else if(t.isObjectTypeAnnotation(prop)){properties.push.apply(properties,_toConsumableArray(prop.properties));}return properties;},[]).filter(function(annotation){return !t.isAnyTypeAnnotation(annotation.value);}));return annotation;}function getMemberExpressionAnnotation(path){if(path.node.computed){return getComputedMemberExpressionAnnotation(path);}var stack=[];var target=path;while(target.isMemberExpression()){stack.push(target);if(target.node.computed){break;}target=target.get('object');}var objectAnnotation=stack.reduceRight(function(last,target){var annotation=last;if(annotation==null){if(stack.length===1){annotation=getAnnotation(target.get('object'));}else {return getAnnotation(target);}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'NullableTypeAnnotation':case 'TypeAnnotation':annotation=annotation.typeAnnotation;}if(annotation.type==='GenericTypeAnnotation'){var typeChecker=getTypeChecker(annotation.id,path.scope);if(typeChecker){annotation=getAnnotation(typeChecker);}else {var binding=path.scope.getBinding(annotation.id.name);if(binding){annotation=getAnnotation(binding.path);}}}switch(annotation.type){case 'AnyTypeAnnotation':return annotation;case 'ObjectTypeAnnotation':var id=target.get('property').node;var _iteratorNormalCompletion13=true;var _didIteratorError13=false;var _iteratorError13=undefined;try{for(var _iterator13=(annotation.properties||[])[Symbol.iterator](),_step13;!(_iteratorNormalCompletion13=(_step13=_iterator13.next()).done);_iteratorNormalCompletion13=true){var _step13$value=_step13.value;var key=_step13$value.key;var value=_step13$value.value;if(key.name===id.name){return value.type==='VoidTypeAnnotation'||value.type==='NullLiteralTypeAnnotation'?t.anyTypeAnnotation():value;}}}catch(err){_didIteratorError13=true;_iteratorError13=err;}finally {try{if(!_iteratorNormalCompletion13&&_iterator13.return){_iterator13.return();}}finally {if(_didIteratorError13){throw _iteratorError13;}}}}return t.anyTypeAnnotation();},null);return objectAnnotation||path.getTypeAnnotation();}function getComputedMemberExpressionAnnotation(path){var object=path.get('object');var property=path.get('property');var objectAnnotation=getAnnotation(object);if(objectAnnotation.type==='TypeAnnotation'||objectAnnotation.type==='NullableTypeAnnotation'){objectAnnotation=objectAnnotation.typeAnnotation;}var propertyAnnotation=getAnnotation(property);if(propertyAnnotation.type==='TypeAnnotation'||propertyAnnotation.type==='NullableTypeAnnotation'){propertyAnnotation=propertyAnnotation.typeAnnotation;}var _property$evaluate=property.evaluate();var confident=_property$evaluate.confident;var value=_property$evaluate.value;if(!confident){return path.getTypeAnnotation();}switch(objectAnnotation.type){case 'TupleTypeAnnotation':if(objectAnnotation.types.length===0){break;}else if(typeof value==='number'){if(!objectAnnotation.types[value]){throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}return objectAnnotation.types[value];}else {throw path.buildCodeFrameError('Invalid computed member expression for tuple: '+humanReadableType(objectAnnotation));}break;}return path.getTypeAnnotation();}function getFunctionForIdentifier(path){if(path.type!=='Identifier'){return false;}var ref=path.scope.getBinding(path.node.name);if(!ref){return false;}return t.isFunction(ref.path.parent)&&ref.path.parentPath;} /**
   * Determine whether the given annotation is for an array.
   */function isStrictlyArrayAnnotation(annotation){switch(annotation.type){case 'ArrayTypeAnnotation':case 'TupleTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return isStrictlyArrayAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':return annotation.types.every(isStrictlyArrayAnnotation);default:return false;}}function compareMaybeUnion(annotation,comparator){var falseCount=0;var _iteratorNormalCompletion14=true;var _didIteratorError14=false;var _iteratorError14=undefined;try{for(var _iterator14=annotation.types[Symbol.iterator](),_step14;!(_iteratorNormalCompletion14=(_step14=_iterator14.next()).done);_iteratorNormalCompletion14=true){var _type5=_step14.value;var result=comparator(_type5);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError14=true;_iteratorError14=err;}finally {try{if(!_iteratorNormalCompletion14&&_iterator14.return){_iterator14.return();}}finally {if(_didIteratorError14){throw _iteratorError14;}}}if(falseCount===annotation.types.length){return false;}else {return null;}} /**
   * Returns `true` if the annotation is compatible with a number,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeNumberAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeNumberAnnotation(annotation.typeAnnotation);case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumericLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':return compareMaybeUnion(annotation,maybeNumberAnnotation);case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**
   * Returns `true` if the annotation is compatible with a string,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeStringAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeStringAnnotation(annotation.typeAnnotation);case 'StringTypeAnnotation':case 'StringLiteral':return true;case 'StringLiteralTypeAnnotation':return null;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion15=true;var _didIteratorError15=false;var _iteratorError15=undefined;try{for(var _iterator15=annotation.types[Symbol.iterator](),_step15;!(_iteratorNormalCompletion15=(_step15=_iterator15.next()).done);_iteratorNormalCompletion15=true){var _type6=_step15.value;var result=maybeStringAnnotation(_type6);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError15=true;_iteratorError15=err;}finally {try{if(!_iteratorNormalCompletion15&&_iterator15.return){_iterator15.return();}}finally {if(_didIteratorError15){throw _iteratorError15;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**
   * Returns `true` if the annotation is compatible with a symbol,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeSymbolAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeSymbolAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'Number':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Symbol':return true;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion16=true;var _didIteratorError16=false;var _iteratorError16=undefined;try{for(var _iterator16=annotation.types[Symbol.iterator](),_step16;!(_iteratorNormalCompletion16=(_step16=_iterator16.next()).done);_iteratorNormalCompletion16=true){var _type7=_step16.value;var result=maybeSymbolAnnotation(_type7);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError16=true;_iteratorError16=err;}finally {try{if(!_iteratorNormalCompletion16&&_iterator16.return){_iterator16.return();}}finally {if(_didIteratorError16){throw _iteratorError16;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**
   * Returns `true` if the annotation is compatible with a boolean,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeBooleanAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeBooleanAnnotation(annotation.typeAnnotation);case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'BooleanLiteral':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Function':case 'Object':case 'String':case 'Number':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion17=true;var _didIteratorError17=false;var _iteratorError17=undefined;try{for(var _iterator17=annotation.types[Symbol.iterator](),_step17;!(_iteratorNormalCompletion17=(_step17=_iterator17.next()).done);_iteratorNormalCompletion17=true){var _type8=_step17.value;var result=maybeBooleanAnnotation(_type8);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError17=true;_iteratorError17=err;}finally {try{if(!_iteratorNormalCompletion17&&_iterator17.return){_iterator17.return();}}finally {if(_didIteratorError17){throw _iteratorError17;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**
   * Returns `true` if the annotation is compatible with a function,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeFunctionAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeFunctionAnnotation(annotation.typeAnnotation);case 'FunctionTypeAnnotation':return true;case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion18=true;var _didIteratorError18=false;var _iteratorError18=undefined;try{for(var _iterator18=annotation.types[Symbol.iterator](),_step18;!(_iteratorNormalCompletion18=(_step18=_iterator18.next()).done);_iteratorNormalCompletion18=true){var _type9=_step18.value;var result=maybeFunctionAnnotation(_type9);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError18=true;_iteratorError18=err;}finally {try{if(!_iteratorNormalCompletion18&&_iterator18.return){_iterator18.return();}}finally {if(_didIteratorError18){throw _iteratorError18;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**
   * Returns `true` if the annotation is compatible with an undefined or null type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeNullableAnnotation(annotation){switch(annotation.type){case 'NullableTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':case 'MixedTypeAnnotation':return true;case 'TypeAnnotation':case 'FunctionTypeParam':return maybeNullableAnnotation(annotation.typeAnnotation);case 'GenericTypeAnnotation':switch(annotation.id.name){case 'Array':case 'Number':case 'Object':case 'String':case 'Boolean':case 'Date':case 'RegExp':return false;case 'Generator':if(annotation.typeParameters&&annotation.typeParameters.params.length>1){return maybeNullableAnnotation(annotation.typeParameters.params[1]);}else {return null;}default:return null;}case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion19=true;var _didIteratorError19=false;var _iteratorError19=undefined;try{for(var _iterator19=annotation.types[Symbol.iterator](),_step19;!(_iteratorNormalCompletion19=(_step19=_iterator19.next()).done);_iteratorNormalCompletion19=true){var _type10=_step19.value;var result=maybeNullableAnnotation(_type10);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError19=true;_iteratorError19=err;}finally {try{if(!_iteratorNormalCompletion19&&_iterator19.return){_iterator19.return();}}finally {if(_didIteratorError19){throw _iteratorError19;}}}if(falseCount===annotation.types.length){return false;}else {return null;}default:return false;}} /**
   * Returns `true` if the annotation is compatible with an object type,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeInstanceOfAnnotation(annotation,expected,typeParameters){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeInstanceOfAnnotation(annotation.typeAnnotation,expected,typeParameters);case 'GenericTypeAnnotation':if(annotation.id.name===expected.name){if(typeParameters.length===0){return true;}if(annotation.typeParameters&&annotation.typeParameters.params.length){var trueCount=0;var nullCount=0;for(var i=0;i<typeParameters.length&&i<annotation.typeParameters.params.length;i++){var result=compareAnnotations(typeParameters[i],annotation.typeParameters.params[i]);if(result===false){return false;}else if(result===true){trueCount++;}else {nullCount++;}}return trueCount>0&&nullCount===0?true:null;}}return null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion20=true;var _didIteratorError20=false;var _iteratorError20=undefined;try{for(var _iterator20=annotation.types[Symbol.iterator](),_step20;!(_iteratorNormalCompletion20=(_step20=_iterator20.next()).done);_iteratorNormalCompletion20=true){var _type11=_step20.value;var _result=maybeInstanceOfAnnotation(_type11,expected,typeParameters);if(_result===true){return true;}else if(_result===false){falseCount++;}}}catch(err){_didIteratorError20=true;_iteratorError20=err;}finally {try{if(!_iteratorNormalCompletion20&&_iterator20.return){_iterator20.return();}}finally {if(_didIteratorError20){throw _iteratorError20;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'||expected.name==='String'||expected.name==='Object'){return false;}else {return null;}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'StringTypeAnnotation':case 'StringLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'NumericLiteralTypeAnnotation':if(expected.name==='Array'||expected.name==='RegExp'||expected.name==='Error'||expected.name==='Function'){return false;}else {return null;}case 'FunctionTypeAnnotation':if(expected.name==='Function'){return true;}else {return null;}default:return null;}} /**
   * Returns `true` if the annotation is compatible with an array,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeArrayAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeArrayAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Array'?true:null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion21=true;var _didIteratorError21=false;var _iteratorError21=undefined;try{for(var _iterator21=annotation.types[Symbol.iterator](),_step21;!(_iteratorNormalCompletion21=(_step21=_iterator21.next()).done);_iteratorNormalCompletion21=true){var _type12=_step21.value;var result=maybeArrayAnnotation(_type12);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError21=true;_iteratorError21=err;}finally {try{if(!_iteratorNormalCompletion21&&_iterator21.return){_iterator21.return();}}finally {if(_didIteratorError21){throw _iteratorError21;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'AnyTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}} /**
   * Returns `true` if the annotation is compatible with an iterable,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeIterableAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeIterableAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':case 'ArrayTypeAnnotation':return true;case 'GenericTypeAnnotation':return annotation.id.name==='Iterable'?true:null;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion22=true;var _didIteratorError22=false;var _iteratorError22=undefined;try{for(var _iterator22=annotation.types[Symbol.iterator](),_step22;!(_iteratorNormalCompletion22=(_step22=_iterator22.next()).done);_iteratorNormalCompletion22=true){var _type13=_step22.value;var result=maybeIterableAnnotation(_type13);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError22=true;_iteratorError22=err;}finally {try{if(!_iteratorNormalCompletion22&&_iterator22.return){_iterator22.return();}}finally {if(_didIteratorError22){throw _iteratorError22;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'BooleanTypeAnnotation':case 'BooleanLiteralTypeAnnotation':case 'NumericLiteralTypeAnnotation':case 'NumberTypeAnnotation':case 'VoidTypeAnnotation':case 'NullLiteralTypeAnnotation':return false;default:return null;}} /**
   * Returns `true` if the annotation is compatible with a tuple,
   * `false` if it definitely isn't, or `null` if we're not sure.
   */function maybeTupleAnnotation(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':case 'NullableTypeAnnotation':return maybeTupleAnnotation(annotation.typeAnnotation);case 'TupleTypeAnnotation':return true;case 'UnionTypeAnnotation':var falseCount=0;var _iteratorNormalCompletion23=true;var _didIteratorError23=false;var _iteratorError23=undefined;try{for(var _iterator23=annotation.types[Symbol.iterator](),_step23;!(_iteratorNormalCompletion23=(_step23=_iterator23.next()).done);_iteratorNormalCompletion23=true){var _type14=_step23.value;var result=maybeTupleAnnotation(_type14);if(result===true){return true;}else if(result===false){falseCount++;}}}catch(err){_didIteratorError23=true;_iteratorError23=err;}finally {try{if(!_iteratorNormalCompletion23&&_iterator23.return){_iterator23.return();}}finally {if(_didIteratorError23){throw _iteratorError23;}}}if(falseCount===annotation.types.length){return false;}else {return null;}case 'GenericTypeAnnotation':case 'AnyTypeAnnotation':case 'ArrayTypeAnnotation':case 'MixedTypeAnnotation':case 'IntersectionTypeAnnotation':return null;default:return false;}}function humanReadableType(annotation){switch(annotation.type){case 'TypeAnnotation':case 'FunctionTypeParam':return humanReadableType(annotation.typeAnnotation);case 'FunctionTypeAnnotation': // @fixme babel doesn't seem to like generating FunctionTypeAnnotations yet
return '('+annotation.params.map(humanReadableType).join(', ')+') => '+humanReadableType(annotation.returnType);case 'GenericTypeAnnotation':var path=getNodePath(annotation);var checker=path&&getTypeChecker(annotation.id,path.scope);if(checker&&checker.node.savedTypeAnnotation){return humanReadableType(checker.node.savedTypeAnnotation);}else {return (0,_babelGenerator2.default)(annotation).code;}default:return (0,_babelGenerator2.default)(annotation).code;}} /**
   * Get the path directly from a node.
   */function getNodePath(node){if(node._paths&&node._paths.length){return node._paths[0];}else {return null;}}function getTypeChecker(id,scope){var checker=scope.getData('typechecker:'+id.name);if(checker){return checker;}var binding=scope.getBinding(id.name);if(binding===undefined){return false;}var path=binding.path;if(path==null){return false;}else if(path.type==='TypeAlias'){return path;}else if(path.type==='VariableDeclaration'&&path.node.isTypeChecker){return path.get('declarations')[0];}else if(path.isImportSpecifier()&&path.parent.importKind==='type'){return path;}return false;}function isTypeChecker(id,scope){return scope.getData('typechecker:'+id.name)!==undefined;}function isPolymorphicType(id,scope){var binding=scope.getBinding(id.name);if(binding!==undefined){return false;}var path=scope.path;while(path&&path.type!=='Program'){var _path=path;var _node=_path.node;if((t.isFunction(_node)||t.isClass(_node))&&_node.typeParameters){var _iteratorNormalCompletion24=true;var _didIteratorError24=false;var _iteratorError24=undefined;try{for(var _iterator24=_node.typeParameters.params[Symbol.iterator](),_step24;!(_iteratorNormalCompletion24=(_step24=_iterator24.next()).done);_iteratorNormalCompletion24=true){var param=_step24.value;param.isPolymorphicType=true;if(param.name===id.name){return true;}}}catch(err){_didIteratorError24=true;_iteratorError24=err;}finally {try{if(!_iteratorNormalCompletion24&&_iterator24.return){_iterator24.return();}}finally {if(_didIteratorError24){throw _iteratorError24;}}}}path=path.parentPath;}return false;}function getPolymorphicType(id,scope){var binding=scope.getBinding(id.name);if(binding!==undefined){return false;}var path=scope.path;while(path&&path.type!=='Program'){var _path2=path;var _node2=_path2.node;if(t.isFunction(_node2)&&_node2.typeParameters){var _iteratorNormalCompletion25=true;var _didIteratorError25=false;var _iteratorError25=undefined;try{for(var _iterator25=_node2.typeParameters.params[Symbol.iterator](),_step25;!(_iteratorNormalCompletion25=(_step25=_iterator25.next()).done);_iteratorNormalCompletion25=true){var param=_step25.value;param.isPolymorphicType=true;if(param.name===id.name){return param;}}}catch(err){_didIteratorError25=true;_iteratorError25=err;}finally {try{if(!_iteratorNormalCompletion25&&_iterator25.return){_iterator25.return();}}finally {if(_didIteratorError25){throw _iteratorError25;}}}}path=path.parent;}return null;}function collectParamChecks(path,context){return path.get('params').map(function(param){var node=param.node;if(node.type==='AssignmentPattern'){if(node.left.typeAnnotation){return createDefaultParamGuard(param,context);}}else if(node.type==='RestElement'){if(node.typeAnnotation){return createRestParamGuard(param,context);}}else if(node.typeAnnotation){return createParamGuard(param,context);}}).filter(identity);}function createParamGuard(path,context){var node=path.node;var scope=path.scope;node.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;var checkable=void 0;if(node.type==='ObjectPattern'){node.name=path.key;checkable=t.memberExpression(t.identifier('arguments'),t.numericLiteral(path.key),true);}else {checkable=node;}var check=checkAnnotation(checkable,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:checkable}),check);}var message=paramTypeErrorMessage(checkable,context,node.typeAnnotation);return guard({check:check,message:message});}function createDefaultParamGuard(path,context){var node=path.node;var scope=path.scope;var id=node.left;var value=node.right;var ok=staticCheckAnnotation(path.get('right'),id.typeAnnotation);if(ok===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid default value for argument "'+id.name+'".',id.typeAnnotation,getAnnotation(path.get('right'))));}return createParamGuard(path.get('left'),context);}function createRestParamGuard(path,context){var node=path.node;var scope=path.scope;var id=node.argument;id.hasBeenTypeChecked=true;node.savedTypeAnnotation=node.typeAnnotation;if(isStrictlyArrayAnnotation(node.typeAnnotation)===false){throw path.buildCodeFrameError(buildErrorMessage('Invalid type annotation for rest argument "'+id.name+'".',t.genericTypeAnnotation(t.identifier('Array')),node.typeAnnotation));}var check=checkAnnotation(id,node.typeAnnotation,scope);if(!check){return;}if(node.optional){check=t.logicalExpression('||',checks.undefined({input:id}),check);}var message=paramTypeErrorMessage(id,context,node.typeAnnotation);return guard({check:check,message:message});}function returnTypeErrorMessage(path,fn,id,context){var node=path.node;var scope=path.scope;var name=fn.id?fn.id.name:'';var annotation=fn.returnType;if(annotation.type==='TypeAnnotation'){annotation=annotation.typeAnnotation;}if(fn.generator&&isGeneratorAnnotation(annotation)&&annotation.typeParameters&&annotation.typeParameters.params.length>1){annotation=annotation.typeParameters.params[1];}var message='Function '+(name?'"'+name+'" ':'')+'return value violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return t.binaryExpression('+',t.stringLiteral(message),id?readableName({inspect:context.inspect,input:id}):node.argument?readableName({inspect:context.inspect,input:node.argument}):t.stringLiteral('undefined'));}function yieldTypeErrorMessage(fn,annotation,id,context){var name=fn.id?fn.id.name:'';var message='Function '+(name?'"'+name+'" ':'')+'yielded an invalid value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}function yieldNextTypeErrorMessage(fn,annotation,id,context){var name=fn.id?fn.id.name:'';var message='Generator '+(name?'"'+name+'" ':'')+'received an invalid next value.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:id}));}function paramTypeErrorMessage(node,context){var typeAnnotation=arguments.length<=2||arguments[2]===undefined?node.typeAnnotation:arguments[2];var name=node.name;if(node.type==='MemberExpression'&&node.object.name==='arguments'){name=node.property.value;}var message='Value of '+(node.optional?'optional ':'')+'argument '+JSON.stringify(name)+' violates contract.\n\nExpected:\n'+humanReadableType(typeAnnotation)+'\n\nGot:\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}function varTypeErrorMessage(node,context){var annotation=node.typeAnnotation;if(node.type==='Identifier'){var _name3=node.name;var message='Value of variable "'+_name3+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return t.binaryExpression('+',t.stringLiteral(message),readableName({inspect:context.inspect,input:node}));}else {var _message='Value of "'+humanReadableType(node)+'" violates contract.\n\nExpected:\n'+humanReadableType(annotation)+'\n\nGot:\n';return t.binaryExpression('+',t.stringLiteral(_message),readableName({inspect:context.inspect,input:node}));}} /**
   * Create a React property validator
   */function generatePropType(annotation,scope,context){var prop=t.identifier('prop');var check=checkAnnotation(prop,annotation,scope);if(check){return propType({check:check,prop:prop,expected:t.stringLiteral(humanReadableType(annotation)),got:readableName({inspect:context.inspect,input:prop})});}else {return t.functionExpression(null,[],t.blockStatement([]));}} /**
   * Determine whether the given node can produce purely boolean results.
   */function isBooleanExpression(node){if(node.type==='BinaryExpression'&&BOOLEAN_BINARY_OPERATORS.indexOf(node.operator)>-1){return true;}else if(node.type==='LogicalExpression'){return isBooleanExpression(node.left)&&isBooleanExpression(node.right);}else {return false;}} /**
   * Convert type specifier to expression.
   */function createTypeExpression(node){if(node.type=='Identifier'){return node;}else if(node.type=='QualifiedTypeIdentifier'){return t.memberExpression(createTypeExpression(node.qualification),createTypeExpression(node.id));}throw this.errorWithNode('Unsupported type: '+node.type);} /**
   * Get name of a type as a string.
   */function getTypeName(node){if(node.type=='Identifier'){return node.name;}else if(node.type=='QualifiedTypeIdentifier'){return getTypeName(node.qualification)+'.'+getTypeName(node.id);}throw this.errorWithNode('Unsupported type: '+node.type);} /**
   * Union two arrays.
   */function union(arr1,arr2){for(var i=0;i<arr2.length;i++){var item=arr2[i];if(arr1.indexOf(item)===-1){arr1.push(item);}}return arr1;} /**
   * Determine whether the given annotation allows any value.
   */function allowsAny(annotation){if(annotation.type==='TypeAnnotation'||annotation.type==='NullableTypeAnnotation'){return allowsAny(annotation.typeAnnotation);}else if(annotation.type==='AnyTypeAnnotation'||annotation.type==='MixedTypeAnnotation'){return true;}else if(annotation.type==='UnionTypeAnnotation'){return annotation.types.some(allowsAny);}else {return false;}} /**
   * Determine whether a given node is nully (null or undefined).
   */function isNodeNully(node){if(node==null){return true;}else if(node.type==='Identifier'&&node.name==='undefined'){return true;}else if(node.type==='Literal'&&node.value===null){return true;}else if(node.type==='UnaryExpression'&&node.operator==='void'){return true;}else {return false;}} /**
   * Determine whether the file should be checked
   */function mustCheckFile(path,opts){if(path.node.leadingComments&&path.node.leadingComments.length){return opts.only&&!skipEnvironment(path.node.leadingComments,opts);}return false;} /**
   * Determine whether the file should be skipped, based on the comments attached to the given node.
   */function maybeSkipFile(path,opts){if(path.node.leadingComments&&path.node.leadingComments.length){if(skipEnvironment(path.node.leadingComments,opts)){return true;}return path.node.leadingComments.some(function(comment){return PRAGMA_IGNORE_FILE.test(comment.value);});}return false;} /**
   * Maybe skip the given path if it has a relevant pragma.
   */function maybeSkip(path){var node=path.node;if(node.hasBeenTypeChecked){return true;}if(node.leadingComments&&node.leadingComments.length){var comment=node.leadingComments[node.leadingComments.length-1];if(PRAGMA_IGNORE_STATEMENT.test(comment.value)){path.skip();return true;}}return false;} /**
   * A function that returns its first argument, useful when filtering.
   */function identity(input){return input;}function getExpression(node){return t.isExpressionStatement(node)?node.expression:node;}function expression(input){var fn=template(input);return function(){var node=fn.apply(undefined,arguments);return getExpression(node);};}};var _babelGenerator=require('babel-generator');var _babelGenerator2=_interopRequireDefault(_babelGenerator);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else {return Array.from(arr);}}