'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      @class Cart
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Accessible via [cart](#foxapi-cart) property of [FoxApi](#foxapi) instance.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _endpoints = require('../endpoints');

var endpoints = _interopRequireWildcard(_endpoints);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// reduce SKU list
function collectLineItems(skus) {
  return _lodash2.default.map(skus, function (l) {
    l.totalPrice = l.quantity * l.price;
    return l;
  });
}

function normalizeResponse(payload) {
  if (payload.lineItems) {
    payload.lineItems.skus = collectLineItems(payload.lineItems.skus);
  }
  return payload;
}

var Cart = function () {
  function Cart(api) {
    _classCallCheck(this, Cart);

    this.api = api;
  }

  /**
   * @method getShippingMethods(): Promise<ShippingMethod[]>
   * Returns available shipping methods.
   */


  _createClass(Cart, [{
    key: 'getShippingMethods',
    value: function getShippingMethods() {
      return this.api.get(endpoints.shippingMethods);
    }

    /**
     * @method chooseShippingMethod(shippingMethodId: Number): Promise<FullOrder>
     * Chooses shipping method for the cart.
     */

  }, {
    key: 'chooseShippingMethod',
    value: function chooseShippingMethod(shippingMethodId) {
      return this.api.patch(endpoints.shippingMethods, { shippingMethodId: shippingMethodId }).then(normalizeResponse);
    }

    /**
     * @method removeShippingMethod(): Promise
     * Removes the shipping method from the cart.
     */

  }, {
    key: 'removeShippingMethod',
    value: function removeShippingMethod() {
      return this.api.delete(endpoints.shippingMethod);
    }

    /**
     * @method setShippingAddress(shippingAddress: CreateAddressPayload): Promise<FullOrder>
     * Creates shipping address for the cart by a given address payload.
     */

  }, {
    key: 'setShippingAddress',
    value: function setShippingAddress(shippingAddress) {
      return this.api.post(endpoints.shippingAddress, shippingAddress).then(normalizeResponse);
    }

    /**
     * @method setShippingAddressById(shippingAddressId: Number): Promise<FullOrder>
     * Creates shipping address for the cart by a given address id.
     */

  }, {
    key: 'setShippingAddressById',
    value: function setShippingAddressById(shippingAddressId) {
      return this.api.patch(endpoints.shippingAddressId(shippingAddressId)).then(normalizeResponse);
    }

    /**
     * @method updateShippingAddress(shippingAddress: UpdateAddressPayload): Promise<FullOrder>
     * Updates shipping address for the cart.
     */

  }, {
    key: 'updateShippingAddress',
    value: function updateShippingAddress(shippingAddress) {
      return this.api.patch(endpoints.shippingAddress, shippingAddress).then(normalizeResponse);
    }

    /**
     * @method removeShippingAddress(): Promise<FullOrder>
     * Removes a shipping address from the cart.
     */

  }, {
    key: 'removeShippingAddress',
    value: function removeShippingAddress() {
      return this.api.delete(endpoints.shippingAddress).then(normalizeResponse);
    }

    /**
     * @method get(): Promise<FullOrder>
     * Returns or creates new cart.
     */

  }, {
    key: 'get',
    value: function get() {
      return this.api.get(endpoints.cart).then(normalizeResponse);
    }

    /**
     * @method checkout(): Promise<FullOrder>
     * Place order from cart.
     */

  }, {
    key: 'checkout',
    value: function checkout() {
      return this.api.post(endpoints.cartCheckout).then(normalizeResponse);
    }

    /**
     * @method updateQuantities(itemQuantities: ItemQuantities): Promise<FullOrder>
     */

  }, {
    key: 'updateQuantities',
    value: function updateQuantities(itemQuantities) {
      var updateSkusPayload = _lodash2.default.map(itemQuantities, function (quantity, sku) {
        return {
          sku: sku,
          quantity: quantity
        };
      });

      return this.api.post(endpoints.cartLineItems, updateSkusPayload).then(normalizeResponse);
    }

    /**
     * @method updateQty(sku: String, qty: Number): Promise<FullOrder>
     * Updates quantity for selected item in the cart
     */

  }, {
    key: 'updateQty',
    value: function updateQty(sku, qty) {
      return this.updateQuantities(_defineProperty({}, sku, qty));
    }

    /**
     * @method addSku(sku: String, quantity: Number): Promise<FullOrder>
     * Adds sku by defined quantity in the cart.
     */

  }, {
    key: 'addSku',
    value: function addSku(sku, quantity) {
      var _this = this;

      return this.get().then(function (cart) {
        var skuData = _lodash2.default.find(_lodash2.default.get(cart, 'lineItems.skus', []), { sku: sku });
        var existsQuantity = skuData ? skuData.quantity : 0;

        return _this.updateQty(sku, existsQuantity + quantity);
      });
    }

    /**
     * @method removeSku(sku: String): Promise<FullOrder>
     * Removes selected sku from the cart.
     */

  }, {
    key: 'removeSku',
    value: function removeSku(sku) {
      return this.updateQty(sku, 0);
    }

    /**
     * @method addCreditCard(creditCardId: Number): Promise<FullOrder>
     * Adds a credit card as payment method for the cart.
     */

  }, {
    key: 'addCreditCard',
    value: function addCreditCard(creditCardId) {
      return this.api.post(endpoints.cartPaymentCreditCarts, { creditCardId: creditCardId }).then(normalizeResponse);
    }

    /**
     * @method removeCreditCards(): Promise<FullOrder>
     * Removes all credit cards payment methods of the cart.
     */

  }, {
    key: 'removeCreditCards',
    value: function removeCreditCards() {
      return this.api.delete(endpoints.cartPaymentCreditCarts).then(normalizeResponse);
    }

    /**
     * @method addGiftCard(giftCardPayload: GiftCardPaymentPayload): Promise<FullOrder>
     * Adds a gift card as payment method for the cart.
     */

  }, {
    key: 'addGiftCard',
    value: function addGiftCard(giftCardPayload) {
      return this.api.post(endpoints.cartPaymentGiftCards, giftCardPayload).then(normalizeResponse);
    }

    /**
     * @method removeGiftCards(): Promise<FullOrder>
     * Removes all gift cards payment methods of the cart.
     */

  }, {
    key: 'removeGiftCards',
    value: function removeGiftCards() {
      return this.api.delete(endpoints.cartPaymentGiftCards).then(normalizeResponse);
    }

    /**
     * @method addGiftCard(amount: Number): Promise<FullOrder>
     * Creates payment method with a given amount using store credit.
     */

  }, {
    key: 'addStoreCredit',
    value: function addStoreCredit(amount) {
      return this.api.post(endpoints.cartPaymentStoreCredits, { amount: amount }).then(normalizeResponse);
    }

    /**
     * @method removeGiftCards(): Promise<FullOrder>
     * Removes all store credits payment methods of the cart.
     */

  }, {
    key: 'removeStoreCrdits',
    value: function removeStoreCrdits() {
      return this.api.delete(endpoints.cartPaymentStoreCredits).then(normalizeResponse);
    }
  }]);

  return Cart;
}();

// @miniclass ItemQuantities (Cart)
// @key sku: Number = {'sku-bread': 2}
// Quantity for sku.


exports.default = Cart;