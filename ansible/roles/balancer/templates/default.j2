upstream search {
  server {{ search_server_http }};
}

upstream phoenix {
  server {{ phoenix_server }};
}

upstream ashes {
    server {{ ashes_server }};
}

server {
  # TODO(jpfuentes2): enable me when we have nginx + lua + HTTP2
  # listen 443 ssl http2 default_server;
  #ssl_certificate    server.crt;
  #ssl_certificate_key server.key;

  listen 80 default_server;
  listen [::]:80 default_server;

  index index.html index.htm index.nginx-debian.html;

  server_name _;

  error_page 500 @500;
  error_page 502 @502;
  error_page 503 @503;
  error_page 504 @504;

  # Create unique UUID to track each request
  set_by_lua $uuid '
      if ngx.var.http_x_request_id == nil then
          return uuid4.getUUID()
      else
          return ngx.var.http_x_request_id
      end
  ';

  # Proxy to ElasticSearch phoenix index for internal use by /api/search
  location /internal-search/ {
      internal;
      proxy_pass http://search/phoenix/;
  }

  # Proxy the internal search location and sanitizes output from ES for external use
  location ~ /api/search/.*/_search {
        default_type 'application/json';
        content_by_lua '

            --forward to internal es
            local json = request_internal_search()

            -- we need only _source filed from the hits
            json.hits.result = map(json.hits.hits, function(hit)
                return hit._source
            end)
            json.hits.pagination = {total = json.hits.total}
            json.hits.hits = nil

            --only show hits
            --TODO handle error better if hits is undefined.
            ngx.say(j.encode(json.hits))
      ';
      break;
  }

  # Proxy the internal search location and sanitizes output from ES for external use
  location ~ /api/search/.*/_count {
        default_type 'application/json';
        content_by_lua '

            --forward to internal es
            local json = request_internal_search()

            --remove shards
            json._shards = nil

            --only show count
            ngx.say(j.encode(json))
      ';
      break;
  }

  # Proxy the internal search location and sanitizes output from ES for external use
  location ~ /api/search/.*/\d+$ {
        default_type 'application/json';
        content_by_lua '

            --forward to internal es
            local json = request_internal_search()

            if json.found == true then
                --only show _source
                json = json._source

                ngx.say(j.encode(json))
            else
                ngx.status = ngx.HTTP_NOT_FOUND
                ngx.header["Content-type"] = "application/json"
                json = { found = false}
                ngx.say(j.encode(json))
            end
      ';
      break;
  }


  # Proxy to phoenix and use basic auth.
  location /api/ {
      proxy_pass http://phoenix/;
      proxy_set_header Authorization "Basic YWRtaW5AYWRtaW4uY29tOnBhc3N3b3Jk";
      proxy_http_version 1.1;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      break;
  }

  # Proxy SSE stream to phoenix.
  location /sse/ {
      proxy_pass http://phoenix/;

      proxy_set_header Authorization "Basic YWRtaW5AYWRtaW4uY29tOnBhc3N3b3Jk";
      proxy_set_header Connection '';
      proxy_http_version 1.1;
      chunked_transfer_encoding off;
      proxy_buffering off;
      proxy_cache off;
  }

  #Finally proxy to ashes
  location / {
      proxy_pass http://ashes/;
  }

  # Error pages
  location @500 {
    if ($http_content_type ~ .*json.*) {
      more_set_headers 'Content-Type: application/json charset=UTF-8';
      return 500 '{"code": 500, "reason": "Internal Server Error"}';
    }
  }

  location @502 {
    if ($http_content_type ~ .*json.*) {
      more_set_headers 'Content-Type: application/json charset=UTF-8';
      return 502 '{"code": 502, "reason": "Bad gateway"}';
    }
  }

  location @503 {
    if ($http_content_type ~ .*json.*) {
      more_set_headers 'Content-Type: application/json charset=UTF-8';
      return 503 '{"code": 503, "reason": "Service Unavailable"}';
    }
  }

  location @504 {
    if ($http_content_type ~ .*json.*) {
      more_set_headers 'Content-Type: application/json charset=UTF-8';
      return 504 '{"code": 504, "reason": "Gateway timeout"}';
    }
  }
}
